{
  "language": "Solidity",
  "sources": {
    "contracts/connectors/PrimitiveConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Connector\r\n * @author  Primitive\r\n * @notice  Low-level abstract contract for Primitive Connectors to inherit from.\r\n * @dev     @primitivefi/v1-connectors@v2.0.0\r\n */\r\n\r\n// Open Zeppelin\r\nimport {Context} from \"@openzeppelin/contracts/GSN/Context.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\n// Primitive\r\nimport {CoreLib, IOption} from \"../libraries/CoreLib.sol\";\r\nimport {\r\n    IPrimitiveConnector,\r\n    IPrimitiveRouter,\r\n    IWETH\r\n} from \"../interfaces/IPrimitiveConnector.sol\";\r\n\r\nabstract contract PrimitiveConnector is IPrimitiveConnector, Context {\nfunction c_0x52f3d072(bytes32 c__0x52f3d072) public pure {}\n\r\n    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\r\n\r\n    IWETH internal _weth; // Canonical WETH9\r\n    IPrimitiveRouter internal _primitiveRouter; // The PrimitiveRouter contract which executes calls.\r\n    mapping(address => mapping(address => bool)) internal _approved; // Stores approvals for future checks.\r\n\r\n    // ===== Constructor =====\r\n\r\n    constructor(address weth_, address primitiveRouter_) public {c_0x52f3d072(0xc4f822295abbc0aca360d1877d46754057753f6abd431ed1195f75874eef175e); /* function */ \n\r\nc_0x52f3d072(0xfda53ee7ef99103baebcf7725e17dc8e25b95c72e3f5bca5a55432d74d0f039c); /* line */ \n        c_0x52f3d072(0xf5747f35f7dacca9f6168a90747289519f686a7167f263aae32d6a5e0a1c3bf5); /* statement */ \n_weth = IWETH(weth_);\r\nc_0x52f3d072(0x63d99f19c1abaae62047cf9bc0796dce81061a3022f399b34833a84399fa1c19); /* line */ \n        c_0x52f3d072(0x053158ce3c7490e4d0cac76109f7f3116ebfeb82582c2dbeb0a46372af1aacd3); /* statement */ \n_primitiveRouter = IPrimitiveRouter(primitiveRouter_);\r\nc_0x52f3d072(0xbbeac5ae0ae955f75a82d2dbafbac543f670bc893391d80c47d3687d2d4b6708); /* line */ \n        c_0x52f3d072(0x9ba64fa3601972656966d5d35d7ab81f73f9a3dc4a87725f28444531d185df33); /* statement */ \ncheckApproval(weth_, primitiveRouter_); // Approves this contract's weth to be spent by router.\r\n    }\r\n\r\n    /**\r\n     * @notice  Reverts if the `option` is not registered in the PrimitiveRouter contract.\r\n     * @dev     Any `option` which is deployed from the Primitive Registry can be registered with the Router.\r\n     * @param   option The Primitive Option to check if registered.\r\n     */\r\n    modifier onlyRegistered(IOption option) {c_0x52f3d072(0xd10e12872bf935f1dc2a4f4315ff5261421852381f71c69826e8aaa485416924); /* function */ \n\r\nc_0x52f3d072(0xdc8d1a3be8f933742740a1607cc563ddf088a566963adb6d1183f8158d92983c); /* line */ \n        c_0x52f3d072(0xf9aaae6454d02aa0a92bf835ca80b638f860c5a67a9cf6a7ebeb72f6b0019af1); /* requirePre */ \nc_0x52f3d072(0x529bfcdbe9c37dd0bf4a51b6666e36ca9d6422bd711a240abe252db09bdc526b); /* statement */ \nrequire(\r\n            _primitiveRouter.getRegisteredOption(address(option)),\r\n            \"PrimitiveSwaps: EVIL_OPTION\"\r\n        );c_0x52f3d072(0xc6817ba8fd36333891f242432493428c040486b2bf717beb58ee07a13ad79dcd); /* requirePost */ \n\r\nc_0x52f3d072(0xb1e4ad7659cf48ceb17c103a1c66c21f698ab7a641b88de31008b0a629d4ad3f); /* line */ \n        _;\r\n    }\r\n\r\n    // ===== External =====\r\n\r\n    /**\r\n     * @notice  Approves the `spender` to pull `token` from this contract.\r\n     * @dev     This contract does not hold funds, infinite approvals cannot be exploited for profit.\r\n     * @param   token The token to approve spending for.\r\n     * @param   spender The address to allow to spend `token`.\r\n     */\r\n    function checkApproval(address token, address spender)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {c_0x52f3d072(0x41fa763c2deabe6cf295c8ab50cb2c8bb9f4be58d9bb4e1251924affcf149b5b); /* function */ \n\r\nc_0x52f3d072(0xd33e771d9d93f48ffedbfd107de20b57029a42ef02cd138e5c01a2145909127e); /* line */ \n        c_0x52f3d072(0x679b2951645fa9fc4a7c46d9192f871f1661681ba22d2877d879b76a2070448b); /* statement */ \nif (!_approved[token][spender]) {c_0x52f3d072(0x531dc5b7839ba0c29fbb791bd6bb9da64a382e434f9bfdb8b84f013af0cc17fd); /* branch */ \n\r\nc_0x52f3d072(0x6f789639fd82bc448fb929ee0cfd7ad50a9db771095ebe4e642147ef28fc7159); /* line */ \n            c_0x52f3d072(0x64c5907af25905429ae7af5ac5c96a71b1773babee6c31be04487fbf20ec279a); /* statement */ \nIERC20(token).safeApprove(spender, uint256(-1));\r\nc_0x52f3d072(0x9c767c5501795b27090ae90fbad0115c4516bb622a6e597747247b6fe4bcaafa); /* line */ \n            c_0x52f3d072(0xbfc3d7de703b1c6fab19964f6208e5bb3562ab36de58f16581ba205a3529deb2); /* statement */ \n_approved[token][spender] = true;\r\n        }else { c_0x52f3d072(0xbc665e94b2128b6b7f4105c88d6a34fd4a0b79c7c06237fd3923874aaad05a2f); /* branch */ \n}\r\nc_0x52f3d072(0xda331a68f81c9c881d7c15dc30f32a6b117e1b79d9df51ef680270c7a40dedb3); /* line */ \n        c_0x52f3d072(0x4d3db8fa0b92c5e90218e4d342db6e5891c751a4b6ce9e510cdd128ed7301895); /* statement */ \nreturn true;\r\n    }\r\n\r\n    // ===== Internal =====\r\n\r\n    /**\r\n     * @notice  Deposits `msg.value` into the Weth contract for Weth tokens.\r\n     * @return  Whether or not ether was deposited into Weth.\r\n     */\r\n    function _depositETH() internal returns (bool) {c_0x52f3d072(0xe44121bbe079f319c8bfb7f9c73a74556c867288467d5b2a48b2b25687f73e41); /* function */ \n\r\nc_0x52f3d072(0x5d2f9c67715e81aa8ed995e71504e53fc49acb4e6937b5a40b638861e880961a); /* line */ \n        c_0x52f3d072(0x1c21aaf6a4f2ee6193da2055dc3531c37ff0db0ec8f4ea1b14da5da833f751eb); /* statement */ \nif (msg.value > 0) {c_0x52f3d072(0x17cba7529a8e9fe6e3cc7d420dd6b1d868d5956506c126b7de80da01f020db0e); /* branch */ \n\r\nc_0x52f3d072(0xf2f12b75494afb5080bc0ad65b1fcdc4f2c9fb221849e7f972ffd83b49700223); /* line */ \n            c_0x52f3d072(0x421a35b706e5d3177c2b55874ca738006d5eb5d752839b1fe902838e11c4be31); /* statement */ \n_weth.deposit.value(msg.value)();\r\nc_0x52f3d072(0xb359a08b54bebec114a21290e1eb690d66588789b2b04916ffc7e82f0fdd3316); /* line */ \n            c_0x52f3d072(0x156c0876808cf372d3a47a7aff510fc70093474796578d692d27c6285d86d166); /* statement */ \nreturn true;\r\n        }else { c_0x52f3d072(0xb0a86596731091e7e542ea20dd8a71e9f5885330f778e7fc99c459aeaa9b0cda); /* branch */ \n}\r\nc_0x52f3d072(0xd1c77e6851915b1afc3015c55b675b8b9627141882310a9b52ac74c513fe1335); /* line */ \n        c_0x52f3d072(0x21337a4fe769a790d835b7ae28a0ef6f0fb9b685381393ff5e15bbfca05ed7b5); /* statement */ \nreturn false;\r\n    }\r\n\r\n    /**\r\n     * @notice  Uses this contract's balance of Weth to withdraw Ether and send it to `getCaller()`.\r\n     */\r\n    function _withdrawETH() internal returns (bool) {c_0x52f3d072(0x88f7d6401927eb7bd8863e682552869c17f418c7952f6642eff14abedc082439); /* function */ \n\r\nc_0x52f3d072(0x532e571e2991aa184610ca21bd974fc6bed8194f23b23b18e810c93c6c27e5ce); /* line */ \n        c_0x52f3d072(0xb496d99eaa21584df2111f766018d26a9d2a9b8dc36073348a53be9fca22b3c7); /* statement */ \nuint256 quantity = IERC20(address(_weth)).balanceOf(address(this));\r\nc_0x52f3d072(0x1028f1574ac21a1ab89acb281fa3e5da3eef930ec11d4e37f4dbe40ececc28ae); /* line */ \n        c_0x52f3d072(0x89a3a4fa484a77864a23df0c29693a3969755c6a73fba5eb9787f9d21fd93169); /* statement */ \nif (quantity > 0) {c_0x52f3d072(0xd4a2bb152cfb713d9e181eca54c5086a73ca28316fc6459e82fd307807cc7ead); /* branch */ \n\r\n            // Withdraw ethers with weth.\r\nc_0x52f3d072(0x2ca37a02898dc23c1795dbe42bcd13527e9b1d9517961d3625c01d7817f8c985); /* line */ \n            c_0x52f3d072(0x4a70fd0a10ca40d240c7f5d574ae74160a53258bf4a96375ca684a24a6fa9f2c); /* statement */ \n_weth.withdraw(quantity);\r\n            // Send ether.\r\nc_0x52f3d072(0x18f384fced790340e3f62e3cf987fd10e862606d13ecf8f67fc88b06e41af3ff); /* line */ \n            c_0x52f3d072(0x4a77186d847d8a8de24fb8c1f4e89a592aec62e614e3fcad4129fcb00ee4ba74); /* statement */ \n(bool success, ) = getCaller().call.value(quantity)(\"\");\r\n            // Revert is call is unsuccessful.\r\nc_0x52f3d072(0xd40ab60160943840ee35f3e37085724cc4db2312f91858fddec087baa7f3d10c); /* line */ \n            c_0x52f3d072(0x3192c335f972117a0f360939fb993845e5dc3c099d7e6c2c2a6dd6218b98a774); /* requirePre */ \nc_0x52f3d072(0x05599b1a16de7dc99b15aa7c44fa46822b30b1f71e8c1ccfe1b2c777d8381715); /* statement */ \nrequire(success, \"Connector: ERR_SENDING_ETHER\");c_0x52f3d072(0xc758dd62b28030a15422e90201952fd2643c42a89ba373d3ed6ebb6544bdbb91); /* requirePost */ \n\r\nc_0x52f3d072(0x3485842fa58a6ba43f11bc7add9a073d3aeddd7d8d2bb7ad0b6b9dbec058ed54); /* line */ \n            c_0x52f3d072(0x624a488edb9d3e76b86a423c2ead7d22f30f01889194212226bd35c8800ec3c9); /* statement */ \nreturn success;\r\n        }else { c_0x52f3d072(0xe2d2f35959a1e5dceb1ed16755e6dc26a82e3a73c37d0e5247a13f0b19528f6a); /* branch */ \n}\r\nc_0x52f3d072(0xe5b1833239196a8286d44f1e06ce7f0a256673d28490504e6caaf2fb4229c834); /* line */ \n        c_0x52f3d072(0xd862a99329090c44313edcec254a6af52375b78f5bb47a3be9182ad916752e27); /* statement */ \nreturn true;\r\n    }\r\n\r\n    /**\r\n     * @notice  Calls the Router to pull `token` from the getCaller() and send them to this contract.\r\n     * @dev     This eliminates the need for users to approve the Router and each connector.\r\n     * @param   token The token to pull from `getCaller()` into this contract.\r\n     * @param   quantity The amount of `token` to pull into this contract.\r\n     * @return  Whether or not the `token` was transferred into this contract.\r\n     */\r\n    function _transferFromCaller(address token, uint256 quantity)\r\n        internal\r\n        returns (bool)\r\n    {c_0x52f3d072(0xb4242a4993911e836d85f85f66a018af3f20a5b25c62a8f76ee5c93666e36a9c); /* function */ \n\r\nc_0x52f3d072(0x1dabd8eb1cbdead6d93050a6033d42d68ef3f0cd44319ff4d59797f743bc5ed8); /* line */ \n        c_0x52f3d072(0x594ba7686114a854c3b5a5fe1e6b36f39818f7a5385ae639e2536a2682db6e3a); /* statement */ \nif (quantity > 0) {c_0x52f3d072(0xd5a84fe2bbe29f67373e85e9fcd5871ad4a5f1eab115d85569483105efdc8ef4); /* branch */ \n\r\nc_0x52f3d072(0xf86be66056fb0ff821a9afc35c2f8e6c7189a33366c5a12e13f81c9d9d439d07); /* line */ \n            c_0x52f3d072(0xa814c4481f0271755ae2c4752ef6363808d65cd111f8d67ed01dc78c66f321b7); /* statement */ \n_primitiveRouter.transferFromCaller(token, quantity);\r\nc_0x52f3d072(0xef38fd7fe3b1783ef3f109522441762940571edae1899fe166ff6478d6955223); /* line */ \n            c_0x52f3d072(0x703416b7729a0b827aa2a4576fe05d248027d48902b4b7300436e58cdd9baf94); /* statement */ \nreturn true;\r\n        }else { c_0x52f3d072(0xffdb8c806cbc880fa8d89e050925b5cf2d45ee3937aa64bc63c35a8c4e592e47); /* branch */ \n}\r\nc_0x52f3d072(0x12f62c4bc6937062053541019963ae48915b2d92e705aaafef01e91d1951e6da); /* line */ \n        c_0x52f3d072(0xc60ae368a668826d47cd6757df9c1975c81676db7c67ddd16c36c8aa2643d571); /* statement */ \nreturn false;\r\n    }\r\n\r\n    /**\r\n     * @notice  Pushes this contract's balance of `token` to `getCaller()`.\r\n     * @dev     getCaller() is the original `msg.sender` of the Router's `execute` fn.\r\n     * @param   token The token to transfer to `getCaller()`.\r\n     * @return  Whether or not the `token` was transferred to `getCaller()`.\r\n     */\r\n    function _transferToCaller(address token) internal returns (bool) {c_0x52f3d072(0x5f89b6fff6a26998ee8d5852868527feb1e5dc2cbeec74be38ae16d38c063293); /* function */ \n\r\nc_0x52f3d072(0x83dc577be5bc2b93d049819560e0ad0a82a7601bcdf6140400ec688e7f17617c); /* line */ \n        c_0x52f3d072(0xe4ee315dc9863c755a9b8c727858e55816711950d53ae3e1c2441fea3ad06499); /* statement */ \nuint256 quantity = IERC20(token).balanceOf(address(this));\r\nc_0x52f3d072(0xeaad68d1b1f672a3c1eadf3ea923e4a119e6ef06e8b67b6169cf7e1184b3a191); /* line */ \n        c_0x52f3d072(0xfa316e159f802b27f83802286867775ca8d526085290a3f516aee24f7bbd95f9); /* statement */ \nif (quantity > 0) {c_0x52f3d072(0x828575e5f6b649347466d1086c57ac4fa3eae06f25cbb68289757d57ae672209); /* branch */ \n\r\nc_0x52f3d072(0xad95c651a7f30428e59dfcf659faa27ab55b3ce1513badbf03df1518dd72ec97); /* line */ \n            c_0x52f3d072(0xfad2a7b12f696f2013a3e1d96b431594c13b2e911cfffc518a03f63417c79d4d); /* statement */ \nIERC20(token).safeTransfer(getCaller(), quantity);\r\nc_0x52f3d072(0x0908cbde81a7b3241eab5628ad1c98e891d474f88a6d1180754752f83d9d5967); /* line */ \n            c_0x52f3d072(0xb9f94b0a5b30c328618db52c03437b8950bbf1d6209a5122c8b24a0b56b4d262); /* statement */ \nreturn true;\r\n        }else { c_0x52f3d072(0xe26ae5929606422086d7ccf8d3367f47cdd034c04b889dda8addbeed2686ebac); /* branch */ \n}\r\nc_0x52f3d072(0xa743c97cee6dae79fca917c9e076a30e0daece4dda29dd2f8eadb13dd50e94e7); /* line */ \n        c_0x52f3d072(0xb81971b84c85fc5fcd4b2137b98cc5c65485ed27b6d1a7b18b3f832a3da3ed64); /* statement */ \nreturn false;\r\n    }\r\n\r\n    /**\r\n     * @notice  Calls the Router to pull `token` from the getCaller() and send them to this contract.\r\n     * @dev     This eliminates the need for users to approve the Router and each connector.\r\n     * @param   token The token to pull from `getCaller()`.\r\n     * @param   quantity The amount of `token` to pull.\r\n     * @param   receiver The `to` address to send `quantity` of `token` to.\r\n     * @return  Whether or not `token` was transferred to `receiver`.\r\n     */\r\n    function _transferFromCallerToReceiver(\r\n        address token,\r\n        uint256 quantity,\r\n        address receiver\r\n    ) internal returns (bool) {c_0x52f3d072(0xc8af3b471357461c956625ddd893b8510d4b89cf811ea167c3a64edd2515914b); /* function */ \n\r\nc_0x52f3d072(0x4c0d61f65db3103569a9d0b3fa1328c82f97a85684671adb5d0068a48dcf25d4); /* line */ \n        c_0x52f3d072(0x8e8603de756e5831f3bb133a25bde29d0de226b82255665fd79d50b99bb02250); /* statement */ \nif (quantity > 0) {c_0x52f3d072(0xf874795053290adf9f0504ba10f6b061260206beca53ceca6cc13470d88d8755); /* branch */ \n\r\nc_0x52f3d072(0x7c12f17ebe6e5040c010b00977e69728fcb88563006ca81e6635c4b782d67d39); /* line */ \n            c_0x52f3d072(0x0d0164307b0d8f8bb8dee688f18f5aae01acdf81ca02413377e09f9851841eea); /* statement */ \n_primitiveRouter.transferFromCallerToReceiver(token, quantity, receiver);\r\nc_0x52f3d072(0x7c8a23b3d7ef4c5aa3e2e971917fbdf7ea931191d7f6c20290b9925d9aa547f7); /* line */ \n            c_0x52f3d072(0x542751fdd8fe62df2fdfc9a05614354e1cbca64804ec8979cdf7739f7f59f593); /* statement */ \nreturn true;\r\n        }else { c_0x52f3d072(0xcf43203280f7787377b6e1613c3000cf4fd1c804ee886568b6bd77189699961f); /* branch */ \n}\r\nc_0x52f3d072(0x71cad5e48ce1224eff1edd466c7ca8be63120db2e7144403c119b8de7592b4c2); /* line */ \n        c_0x52f3d072(0xb192066d68a66e3a90b6188723c84e4c20e9ec73e526c42deed09900c44c068c); /* statement */ \nreturn false;\r\n    }\r\n\r\n    /**\r\n     * @notice  Uses this contract's balance of underlyingTokens to mint optionTokens to this contract.\r\n     * @param   optionToken The Primitive Option to mint.\r\n     * @return  (uint, uint) (longOptions, shortOptions)\r\n     */\r\n    function _mintOptions(IOption optionToken) internal returns (uint256, uint256) {c_0x52f3d072(0x7b314a0c57e0d439dd4c840ef56f12ca8ad0628cff0041ab60928474cff803f1); /* function */ \n\r\nc_0x52f3d072(0xf3a0fa425b57d03c85162788df1ccd47b3d4991cb2e8369593301bd8c8d49ae4); /* line */ \n        c_0x52f3d072(0xd39847f0da279ebb7736d5ce2d8270d06eef3d2f04013110b3359cc4f9880970); /* statement */ \naddress underlying = optionToken.getUnderlyingTokenAddress();\r\nc_0x52f3d072(0xf7eb321e75695b6df454dbe0749cf61818fadbcf4f0e476e92c4f2fd29ff4299); /* line */ \n        c_0x52f3d072(0x1edb29b9bfb71cf5d5d1c1af099f568876d6e85c5bb0c4c65fd0060bd91a09af); /* statement */ \n_transferBalanceToReceiver(underlying, address(optionToken)); // Sends to option contract\r\nc_0x52f3d072(0xbad24b4da64a26b352fa2673c888f40a1c71dae83a873fbf82241cd4da6f1540); /* line */ \n        c_0x52f3d072(0x5c5257fce7868fba03e67f7dc7982a0376a570c3756c1da45b7fac5babc16390); /* statement */ \nreturn optionToken.mintOptions(address(this));\r\n    }\r\n\r\n    /**\r\n     * @notice  Uses this contract's balance of underlyingTokens to mint optionTokens to `receiver`.\r\n     * @param   optionToken The Primitive Option to mint.\r\n     * @param   receiver The address that will received the minted long and short optionTokens.\r\n     * @return  (uint, uint) Returns the (long, short) option tokens minted\r\n     */\r\n    function _mintOptionsToReceiver(IOption optionToken, address receiver)\r\n        internal\r\n        returns (uint256, uint256)\r\n    {c_0x52f3d072(0xd339ab9832b2c5ba90441794de9c4b0df4cabaecdbe1b6871f2d0a59509720ef); /* function */ \n\r\nc_0x52f3d072(0x03181b68a7d2a484035076eb61006736b1240326771a795696179f020b2abac0); /* line */ \n        c_0x52f3d072(0xe26b0cc895ef1458cb3924d91a555f94b3f5198366c33b754ec4c8bc8be3b478); /* statement */ \naddress underlying = optionToken.getUnderlyingTokenAddress();\r\nc_0x52f3d072(0x690536b609248143fe72015392ebee00123f77fb4affebbbffd3d152efef5686); /* line */ \n        c_0x52f3d072(0xc97e5a8a1cd48063b4635c88397e96fc23a4636677a9f0704be255b0012ffaf0); /* statement */ \n_transferBalanceToReceiver(underlying, address(optionToken)); // Sends to option contract\r\nc_0x52f3d072(0xd987c5dc394bbe78f4801e73d14bdda17b6530580e291ea036471c9c1cabdf7e); /* line */ \n        c_0x52f3d072(0x3cf6b7f19a4a1281a4bd98f0771f792a3ef73dcf1befd6245f944011b366725a); /* statement */ \nreturn optionToken.mintOptions(receiver);\r\n    }\r\n\r\n    /**\r\n     * @notice  Pulls underlying tokens from `getCaller()` to option contract, then invokes mintOptions().\r\n     * @param   optionToken The option token to mint.\r\n     * @param   quantity The amount of option tokens to mint.\r\n     * @return  (uint, uint) Returns the (long, short) option tokens minted\r\n     */\r\n    function _mintOptionsFromCaller(IOption optionToken, uint256 quantity)\r\n        internal\r\n        returns (uint256, uint256)\r\n    {c_0x52f3d072(0xe1c1a90b26430eaa168bca3cb89bbf8ed9df48a88a79f75fab4f0578aa0ebbdf); /* function */ \n\r\nc_0x52f3d072(0xade4b36fea87e1ae69935a8cc8159173c03ebc60efcf721ab8e06c0a11d17350); /* line */ \n        c_0x52f3d072(0x7f84454b8b60072440ef8dee1d80b324332849cb9006227408ce5d725831ab6f); /* requirePre */ \nc_0x52f3d072(0x77b2ac5606de46f27b8515c3541914826a260614859df7d8d85dba263360c485); /* statement */ \nrequire(quantity > 0, \"ERR_ZERO\");c_0x52f3d072(0xfb8dbccf109663405842b4e9d36152226af05714aa9924291d14e84cc49ed0be); /* requirePost */ \n\r\nc_0x52f3d072(0x30341bb9a6ad7d78c60e0747e526ac94521e191ddda7ca0b7aa77b5906782e2d); /* line */ \n        c_0x52f3d072(0x86eae1c2be42f1f65c10dc06d8e87f24556fb23e7a7874d0672bef18d2c99546); /* statement */ \n_transferFromCallerToReceiver(\r\n            optionToken.getUnderlyingTokenAddress(),\r\n            quantity,\r\n            address(optionToken)\r\n        );\r\nc_0x52f3d072(0x30aac97390ed29dcba6ab164baccc4fa62396ba16304ce7acba6a52a2391544b); /* line */ \n        c_0x52f3d072(0xc62eccdc70ce6d26c2286b3f4619b48947f4f9c1f44f0a641ca374eb8dae3555); /* statement */ \nreturn optionToken.mintOptions(address(this));\r\n    }\r\n\r\n    /**\r\n     * @notice  Multi-step operation to close options.\r\n     *          1. Transfer balanceOf `redeem` option token to the option contract.\r\n     *          2. If NOT expired, pull `option` tokens from `getCaller()` and send to option contract.\r\n     *          3. Invoke `closeOptions()` to burn the options and release underlyings to this contract.\r\n     * @return  The amount of underlyingTokens released to this contract.\r\n     */\r\n    function _closeOptions(IOption optionToken) internal returns (uint256) {c_0x52f3d072(0x93d8e1e2096b61ec88797ebcb6d73f9b939cb654cacc781365a364a35a51e155); /* function */ \n\r\nc_0x52f3d072(0x64b3d3a098393290f447ce26c7c021187be6770ec5afcaa720fb14c98172bcd3); /* line */ \n        c_0x52f3d072(0xb436e1597c9766dbce74b916cc32e64ef9a9bf06deac546fdc5ff411fda4c5ef); /* statement */ \naddress redeem = optionToken.redeemToken();\r\nc_0x52f3d072(0xecb1d873b29bf57102baf0613fc1ff0f51407d2d3a14fb90b32e2e43610ac95f); /* line */ \n        c_0x52f3d072(0xc71392beee5046f2c43b9ffdb96d9bcc8a7f8c1e0ed2d5db8b5b50495c44d369); /* statement */ \nuint256 quantity = _transferBalanceToReceiver(redeem, address(optionToken));\r\n\r\nc_0x52f3d072(0x600865d8574213c2d981bde868d2801be10d119bab3d1b85d24ce60c512821b7); /* line */ \n        c_0x52f3d072(0xadfe3220a7834bf6d4b5dab75aa3e47af55d8fcf8a6395dc625814f0693559ec); /* statement */ \nif (optionToken.getExpiryTime() >= now) {c_0x52f3d072(0x75adf187559c52bc137675196375fe7ce824c03aa1942ab1de0dffa691ae2263); /* branch */ \n\r\nc_0x52f3d072(0xb3b3567ae884651b92bb3198f455fd4932429c752c5f7ad31782c6f51644e6c6); /* line */ \n            c_0x52f3d072(0x00c062a19a1d7e13b869a79074c9b7d8817c3989841ed5cf357bdb54a2c9be4e); /* statement */ \n_transferFromCallerToReceiver(\r\n                address(optionToken),\r\n                CoreLib.getProportionalLongOptions(optionToken, quantity),\r\n                address(optionToken)\r\n            );\r\n        }else { c_0x52f3d072(0x8ca09a1d69e83fcfcfe609ccda4e2bcbdb3bb62bddf379e2ce79d300a1ca1823); /* branch */ \n}\r\n\r\nc_0x52f3d072(0xea18bd0427b31576e51ef5d986ac1f2cce5d43535e1afb476f8c63a156697b7e); /* line */ \n        c_0x52f3d072(0xff728fbde1b4ef743a465d2cd629da509f78972cb57f0142d8f3f853744bcc51); /* statement */ \n(, , uint256 outputUnderlyings) = optionToken.closeOptions(address(this));\r\nc_0x52f3d072(0x33f5fb68e89e2774fe308f724fe9fc23415d50831cf5c0113d6cb3968e821c8c); /* line */ \n        c_0x52f3d072(0xc7aeab27feece84a83aba33d50f23341c173e440d89438334f3139d724cb915a); /* statement */ \nreturn outputUnderlyings;\r\n    }\r\n\r\n    /**\r\n     * @notice  Multi-step operation to exercise options.\r\n     *          1. Transfer balanceOf `strike` token to option contract.\r\n     *          2. Transfer `amount` of options to exercise to option contract.\r\n     *          3. Invoke `exerciseOptions()` and specify `getCaller()` as the receiver.\r\n     * @dev     If the balanceOf `strike` and `amount` of options are not in correct proportions, call will fail.\r\n     * @param   optionToken The option to exercise.\r\n     * @param   amount The quantity of options to exercise.\r\n     */\r\n    function _exerciseOptions(IOption optionToken, uint256 amount)\r\n        internal\r\n        returns (uint256, uint256)\r\n    {c_0x52f3d072(0x0451a5dd2833cbb644bebf411a110eb4a0373f678b89ac92966e545ead304498); /* function */ \n\r\nc_0x52f3d072(0x789d7963dd01318f9cc8c4da7a121ec2972dc8fc9ea394d53f9e624006542f15); /* line */ \n        c_0x52f3d072(0x797e9d5bbb1778c3f8631fee2fc8fadb2c1f6ba12d57ee26a7cf9ef0682f8f7f); /* statement */ \naddress strike = optionToken.getStrikeTokenAddress();\r\nc_0x52f3d072(0xaadea5b3416191f587b691a591873e6022e9fcb30984bf56dbb3b91ce06b3ba2); /* line */ \n        c_0x52f3d072(0x2a83f49acecda509889d1aa90c5625d5a4a343d37a7fa0c84f14f46cb114017e); /* statement */ \n_transferBalanceToReceiver(strike, address(optionToken));\r\nc_0x52f3d072(0x3d7a8426ee7c1a250ac3f3c8571d0b9282de0413fe9ca1f0775ae2614efeb89e); /* line */ \n        c_0x52f3d072(0x3817ec3bec1ebb0f3ea6db7de019a2e1af5e22d4e2210671e69bb5723cabe163); /* statement */ \nIERC20(address(optionToken)).safeTransfer(address(optionToken), amount);\r\nc_0x52f3d072(0xf5e5d3f005e0940cdce1ba49f3124483d14650c6813d9b522edd58519adf61d1); /* line */ \n        c_0x52f3d072(0x4f28adbff3256eb656028c39b952e511c67230be50ed2aef3f7e543f1a9add26); /* statement */ \nreturn optionToken.exerciseOptions(getCaller(), amount, new bytes(0));\r\n    }\r\n\r\n    /**\r\n     * @notice  Transfers this contract's balance of Redeem tokens and invokes the redemption function.\r\n     * @param   optionToken The optionToken to redeem, not the redeem token itself.\r\n     */\r\n    function _redeemOptions(IOption optionToken) internal returns (uint256) {c_0x52f3d072(0x83f82573b9db8bc559d8dd9f13e056a66505e9a70ee7c7f4d1130fed2395d813); /* function */ \n\r\nc_0x52f3d072(0x70973adf3f2d7d353e67c3dc366c0d16ce3dba97cdebc8406a81de37f833fc7c); /* line */ \n        c_0x52f3d072(0xb970a9a8f79eda84c7199baf06e23d36e03e39dd8aa7985e2f779fc3467503b1); /* statement */ \naddress redeem = optionToken.redeemToken();\r\nc_0x52f3d072(0x01e48a8c28fd8c10b2099c1e5ba044b7183d21466d428aa6c260e117f573f250); /* line */ \n        c_0x52f3d072(0x29952ecaff51a114253106fd37c2851b174d7857dabfa497b0729690bacd5a56); /* statement */ \n_transferBalanceToReceiver(redeem, address(optionToken));\r\nc_0x52f3d072(0x83a7318a28734e033a59d3a7714aa8d31b9d0f19f4be8857e15a1dce3dda56b5); /* line */ \n        c_0x52f3d072(0x38d2e34f10cad8cd7ffd898197fcdb38301ab44dd0487a423863473c14f14b93); /* statement */ \nreturn optionToken.redeemStrikeTokens(getCaller());\r\n    }\r\n\r\n    /**\r\n     * @notice  Utility function to transfer this contract's balance of `token` to `receiver`.\r\n     * @param   token The token to transfer.\r\n     * @param   receiver The address that receives the token.\r\n     * @return  Returns the quantity of `token` transferred.\r\n     */\r\n    function _transferBalanceToReceiver(address token, address receiver)\r\n        internal\r\n        returns (uint256)\r\n    {c_0x52f3d072(0xfccaf13ec0807537b419caed675817e4aa34ee465c56a7d566c3f6154f4b3f02); /* function */ \n\r\nc_0x52f3d072(0x8fe267b12bb855194dc7911e7d4da80c3992cf4f96b96203937574d1ebb842e9); /* line */ \n        c_0x52f3d072(0xc255c5a6071d0ed7505903da895cd3c74afd4951abefe0c68bb83c0aa3244da4); /* statement */ \nuint256 quantity = IERC20(token).balanceOf(address(this));\r\nc_0x52f3d072(0x07caa20a23b92d89a1940e6efbe2c330e7c2a2c4404c7f10bf6056deaadcd6eb); /* line */ \n        c_0x52f3d072(0x93b372b57ea47311f1940b606ba011c1cdbc4d83a8f2573d68400558174d7588); /* statement */ \nIERC20(token).safeTransfer(receiver, quantity);\r\nc_0x52f3d072(0x13292e64467494f60ead50a729f8a111eabf9507850b2665aa4dd51bae6d6965); /* line */ \n        c_0x52f3d072(0xc62da2cd7a630567f04ec26c6730c4fe973b2b386ce7673aea069fd5eedcaff5); /* statement */ \nreturn quantity;\r\n    }\r\n\r\n    // ===== Fallback =====\r\n\r\n    receive() external payable {\r\nc_0x52f3d072(0x32243132a7aef2cf0b9e64c7dd9b01bbc6ada466674b573a2597d08e59930de8); /* line */ \n        assert(_msgSender() == address(_weth)); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    // ===== View =====\r\n\r\n    /**\r\n     * @notice  Returns the Weth contract address.\r\n     */\r\n    function getWeth() public view override returns (IWETH) {c_0x52f3d072(0x987b008b4e234fef403afcee6c16033383bcf4f2e3571363a07b0138fa4ff3b5); /* function */ \n\r\nc_0x52f3d072(0xf7df18e38d18b36b30ea7ca5997196da1c36a564632a65989e40d450c6cfb59e); /* line */ \n        c_0x52f3d072(0x667e22b29c16e3f1cffd60687e293e7b39e4fe142ff0299c911ff8c7dbc7545b); /* statement */ \nreturn _weth;\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns the state variable `_CALLER` in the Primitive Router.\r\n     */\r\n    function getCaller() public view override returns (address) {c_0x52f3d072(0xdb83547c0a280d4c19d2d1e554721f81e17186d3ec106e6f6cd22f0ef0d78adf); /* function */ \n\r\nc_0x52f3d072(0xef3f03543b4fd6d23306d0b275c9e80e12eca33aa0c78991db4de9fdc2308126); /* line */ \n        c_0x52f3d072(0x9baa3f470069e4b70b69707ebf721e7bd517dcccbf93119794e64ca0b3ab4226); /* statement */ \nreturn _primitiveRouter.getCaller();\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns the Primitive Router contract address.\r\n     */\r\n    function getPrimitiveRouter() public view override returns (IPrimitiveRouter) {c_0x52f3d072(0x57aed71c1e5f351b77d5843ce79707941a5fb7673b95e12c962192a318ae4dab); /* function */ \n\r\nc_0x52f3d072(0x1c29fd3380d5f263a8f1cb0e18f58b1d51e025eba7e682cbfea78fb23b699f78); /* line */ \n        c_0x52f3d072(0xb48fc131aa8c8cae914d181e8daca958ca2229757e1873cc182004d709403408); /* statement */ \nreturn _primitiveRouter;\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns whether or not `spender` is approved to spend `token`, from this contract.\r\n     */\r\n    function isApproved(address token, address spender)\r\n        public\r\n        view\r\n        override\r\n        returns (bool)\r\n    {c_0x52f3d072(0xe968cdb907907e2f5043c89942e910c874e83ae287c557411f910ac376c44a51); /* function */ \n\r\nc_0x52f3d072(0x4202ef6e3d4d55e29b0cf0d6fe14df488ee8f369d6d4df1ad54f3649e92b45af); /* line */ \n        c_0x52f3d072(0x1a8b0fcfe9cf071c8208ee4cb6a26a4a35d875b6aada9e4fbc2bce3df5a868ba); /* statement */ \nreturn _approved[token][spender];\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/libraries/CoreLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Swaps Lib\r\n * @author  Primitive\r\n * @notice  Library for calculating different proportions of long and short option tokens.\r\n * @dev     @primitivefi/v1-connectors@2.0.0\r\n */\r\n\r\nimport {IOption} from \"@primitivefi/contracts/contracts/option/interfaces/ITrader.sol\";\r\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\nlibrary CoreLib {\nfunction c_0xaf2f700a(bytes32 c__0xaf2f700a) public pure {}\n\r\n    using SafeMath for uint256; // Reverts on math underflows/overflows\r\n\r\n    /**\r\n     * @dev     Calculates the proportional quantity of long option tokens per short option token.\r\n     * @notice  For each long option token, there is quoteValue / baseValue quantity of short option tokens.\r\n     * @param   optionToken The Option to use to calculate proportional amounts. Each option has different proportions.\r\n     * @param   short The amount of short options used to calculate the proportional amount of long option tokens.\r\n     * @return  The proportional amount of long option tokens based on `short`.\r\n     */\r\n    function getProportionalLongOptions(IOption optionToken, uint256 short)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {c_0xaf2f700a(0x47d98416b05ff8731673adad021ff96b284ad86e525b9199fddab1f084ae782f); /* function */ \n\r\nc_0xaf2f700a(0x6009d67ec6804bfe99c1f579fab2e4f5229b32d25359b37c64a5d9d3dd930d10); /* line */ \n        c_0xaf2f700a(0x1c73eb6990507e5d01ff6048166a8d56015d2bf8f6a4f775b245b7950a41a715); /* statement */ \nreturn short.mul(optionToken.getBaseValue()).div(optionToken.getQuoteValue());\r\n    }\r\n\r\n    /**\r\n     * @dev     Calculates the proportional quantity of short option tokens per long option token.\r\n     * @notice  For each short option token, there is baseValue / quoteValue quantity of long option tokens.\r\n     * @param   optionToken The Option to use to calculate proportional amounts. Each option has different proportions.\r\n     * @param   long The amount of long options used to calculate the proportional amount of short option tokens.\r\n     * @return  The proportional amount of short option tokens based on `long`.\r\n     */\r\n    function getProportionalShortOptions(IOption optionToken, uint256 long)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {c_0xaf2f700a(0x7d0b0b7879d66573cdfd6b4b63fa8faae5a7ae15f6e5b11e81464b8af88a61a3); /* function */ \n\r\nc_0xaf2f700a(0x06a79750cda7e3138ceb6aaff45efe3b40bd3d5b19ff288ad8c9d1433fd28a35); /* line */ \n        c_0xaf2f700a(0x17bac95bce6b49f60b04a873cdc1ddcd5e9d2100e176c8bb70fe27e3198d3633); /* statement */ \nreturn long.mul(optionToken.getQuoteValue()).div(optionToken.getBaseValue());\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IPrimitiveConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\nimport {IPrimitiveRouter} from \"../interfaces/IPrimitiveRouter.sol\";\r\nimport {IWETH} from \"../interfaces/IWETH.sol\";\r\n\r\ninterface IPrimitiveConnector {\r\n    // ===== External =====\r\n\r\n    function checkApproval(address token, address spender) external returns (bool);\r\n\r\n    // ===== View =====\r\n\r\n    function getWeth() external view returns (IWETH);\r\n\r\n    function getCaller() external view returns (address);\r\n\r\n    function getPrimitiveRouter() external view returns (IPrimitiveRouter);\r\n\r\n    function isApproved(address token, address spender) external view returns (bool);\r\n}\r\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@primitivefi/contracts/contracts/option/interfaces/ITrader.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.2;\r\n\r\nimport { IOption } from \"./IOption.sol\";\r\n\r\ninterface ITrader {\r\n    function safeMint(\r\n        IOption optionToken,\r\n        uint256 mintQuantity,\r\n        address receiver\r\n    ) external returns (uint256, uint256);\r\n\r\n    function safeExercise(\r\n        IOption optionToken,\r\n        uint256 exerciseQuantity,\r\n        address receiver\r\n    ) external returns (uint256, uint256);\r\n\r\n    function safeRedeem(\r\n        IOption optionToken,\r\n        uint256 redeemQuantity,\r\n        address receiver\r\n    ) external returns (uint256);\r\n\r\n    function safeClose(\r\n        IOption optionToken,\r\n        uint256 closeQuantity,\r\n        address receiver\r\n    )\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function safeUnwind(\r\n        IOption optionToken,\r\n        uint256 unwindQuantity,\r\n        address receiver\r\n    )\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n}\r\n"
    },
    "@primitivefi/contracts/contracts/option/interfaces/IOption.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.2;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ninterface IOption is IERC20 {\r\n    function mintOptions(address receiver) external returns (uint256, uint256);\r\n\r\n    function exerciseOptions(\r\n        address receiver,\r\n        uint256 outUnderlyings,\r\n        bytes calldata data\r\n    ) external returns (uint256, uint256);\r\n\r\n    function redeemStrikeTokens(address receiver) external returns (uint256);\r\n\r\n    function closeOptions(address receiver)\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function redeemToken() external view returns (address);\r\n\r\n    function getStrikeTokenAddress() external view returns (address);\r\n\r\n    function getUnderlyingTokenAddress() external view returns (address);\r\n\r\n    function getBaseValue() external view returns (uint256);\r\n\r\n    function getQuoteValue() external view returns (uint256);\r\n\r\n    function getExpiryTime() external view returns (uint256);\r\n\r\n    function underlyingCache() external view returns (uint256);\r\n\r\n    function strikeCache() external view returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function getCacheBalances() external view returns (uint256, uint256);\r\n\r\n    function getAssetAddresses()\r\n        external\r\n        view\r\n        returns (\r\n            address,\r\n            address,\r\n            address\r\n        );\r\n\r\n    function getParameters()\r\n        external\r\n        view\r\n        returns (\r\n            address _underlyingToken,\r\n            address _strikeToken,\r\n            address _redeemToken,\r\n            uint256 _base,\r\n            uint256 _quote,\r\n            uint256 _expiry\r\n        );\r\n\r\n    function initRedeemToken(address _redeemToken) external;\r\n\r\n    function updateCacheBalances() external;\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/interfaces/IPrimitiveRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\nimport {\r\n    IOption,\r\n    IERC20\r\n} from \"@primitivefi/contracts/contracts/option/interfaces/IOption.sol\";\r\nimport {\r\n    IRegistry\r\n} from \"@primitivefi/contracts/contracts/option/interfaces/IRegistry.sol\";\r\nimport {IWETH} from \"./IWETH.sol\";\r\n\r\ninterface IPrimitiveRouter {\r\n    // ===== Admin =====\r\n\r\n    function halt() external;\r\n\r\n    // ===== Registration =====\r\n    function setRegisteredOptions(address[] calldata optionAddresses)\r\n        external\r\n        returns (bool);\r\n\r\n    function setRegisteredConnectors(\r\n        address[] calldata connectors,\r\n        bool[] calldata isValid\r\n    ) external returns (bool);\r\n\r\n    // ===== Operations =====\r\n\r\n    function transferFromCaller(address token, uint256 amount) external returns (bool);\r\n\r\n    function transferFromCallerToReceiver(\r\n        address token,\r\n        uint256 amount,\r\n        address receiver\r\n    ) external returns (bool);\r\n\r\n    // ===== Execution =====\r\n\r\n    function executeCall(address connector, bytes calldata params) external payable;\r\n\r\n    // ==== View ====\r\n\r\n    function getWeth() external view returns (IWETH);\r\n\r\n    function getRoute() external view returns (address);\r\n\r\n    function getCaller() external view returns (address);\r\n\r\n    function getRegistry() external view returns (IRegistry);\r\n\r\n    function getRegisteredOption(address option) external view returns (bool);\r\n\r\n    function getRegisteredConnector(address connector) external view returns (bool);\r\n\r\n    function apiVersion() external pure returns (string memory);\r\n}\r\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function withdraw(uint256) external;\r\n}\r\n"
    },
    "@primitivefi/contracts/contracts/option/interfaces/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.2;\r\n\r\ninterface IRegistry {\r\n    function pauseDeployments() external;\r\n\r\n    function unpauseDeployments() external;\r\n\r\n    function deployOption(\r\n        address underlyingToken,\r\n        address strikeToken,\r\n        uint256 base,\r\n        uint256 quote,\r\n        uint256 expiry\r\n    ) external returns (address);\r\n\r\n    function setOptionFactory(address optionFactory_) external;\r\n\r\n    function setRedeemFactory(address redeemFactory_) external;\r\n\r\n    function optionFactory() external returns (address);\r\n\r\n    function redeemFactory() external returns (address);\r\n\r\n    function verifyToken(address tokenAddress) external;\r\n\r\n    function verifyExpiry(uint256 expiry) external;\r\n\r\n    function unverifyToken(address tokenAddress) external;\r\n\r\n    function unverifyExpiry(uint256 expiry) external;\r\n\r\n    function calculateOptionAddress(\r\n        address underlyingToken,\r\n        address strikeToken,\r\n        uint256 base,\r\n        uint256 quote,\r\n        uint256 expiry\r\n    ) external view returns (address);\r\n\r\n    function getOptionAddress(\r\n        address underlyingToken,\r\n        address strikeToken,\r\n        uint256 base,\r\n        uint256 quote,\r\n        uint256 expiry\r\n    ) external view returns (address);\r\n\r\n    function isVerifiedOption(address optionAddress)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n"
    },
    "contracts/connectors/PrimitiveSwaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Router\r\n * @author  Primitive\r\n * @notice  Swap option tokens on Uniswap & Sushiswap venues.\r\n * @dev     @primitivefi/v1-connectors@v2.0.0\r\n */\r\n\r\n// Open Zeppelin\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n// Uniswap\r\nimport {\r\n    IUniswapV2Callee\r\n} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol\";\r\n// Primitive\r\nimport {\r\n    IPrimitiveSwaps,\r\n    IUniswapV2Router02,\r\n    IUniswapV2Factory,\r\n    IUniswapV2Pair,\r\n    IOption,\r\n    IERC20Permit\r\n} from \"../interfaces/IPrimitiveSwaps.sol\";\r\nimport {PrimitiveConnector} from \"./PrimitiveConnector.sol\";\r\nimport {SwapsLib, SafeMath} from \"../libraries/SwapsLib.sol\";\r\n\r\ninterface DaiPermit {\r\n    function permit(\r\n        address holder,\r\n        address spender,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        bool allowed,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\ncontract PrimitiveSwaps is\r\n    PrimitiveConnector,\r\n    IPrimitiveSwaps,\r\n    IUniswapV2Callee,\r\n    ReentrancyGuard\r\n{\nfunction c_0xc019abf3(bytes32 c__0xc019abf3) public pure {}\n\r\n    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\r\n    using SafeMath for uint256; // Reverts on math underflows/overflows\r\n\r\n    event Initialized(address indexed from); // Emitted on deployment.\r\n    event Buy(\r\n        address indexed from,\r\n        address indexed option,\r\n        uint256 quantity,\r\n        uint256 premium\r\n    );\r\n    event Sell(\r\n        address indexed from,\r\n        address indexed option,\r\n        uint256 quantity,\r\n        uint256 payout\r\n    );\r\n\r\n    IUniswapV2Factory private _factory; // The Uniswap V2 _factory contract to get pair addresses from\r\n    IUniswapV2Router02 private _router; // The Uniswap contract used to interact with the protocol\r\n\r\n    modifier onlySelf() {c_0xc019abf3(0xc2e225c79f7e671ff4bf41cac84362bb075ba72d16677c8567db6f74b170f846); /* function */ \n\r\nc_0xc019abf3(0xfc762a73567969b510d1707aa79865a4020a7adf49fe68971cc458ba130d6510); /* line */ \n        c_0xc019abf3(0x5b22d7d84c53eb97fe40450aae57f0e3d5a204069b7c154313034dac8070c5c4); /* requirePre */ \nc_0xc019abf3(0xfde4dcb7eae8bbdb645d4d45812eb7c331f5be9b6c9ec12a02c8a803a150177b); /* statement */ \nrequire(_msgSender() == address(this), \"PrimitiveSwaps: NOT_SELF\");c_0xc019abf3(0xb6b8af356ebe236647be49f8c2b1d7c3b08aa7fac9edf7a31274089d2116383a); /* requirePost */ \n\r\nc_0xc019abf3(0x0bbc1c853b3c8960665ff6d1b431f565b5f39ce78564e455724e5c9107f078ed); /* line */ \n        _;\r\n    }\r\n\r\n    // ===== Constructor =====\r\n    constructor(\r\n        address weth_,\r\n        address primitiveRouter_,\r\n        address factory_,\r\n        address router_\r\n    ) public PrimitiveConnector(weth_, primitiveRouter_) {c_0xc019abf3(0x87ce256d1d58421da070515a8f5a127841ba998e38cf8404a93b8d1c4f43aa88); /* function */ \n\r\nc_0xc019abf3(0x5b8f4659d434746523b27b38393a8b7e7ff2dab55caf6f2a37ffa2cf73fcc08a); /* line */ \n        c_0xc019abf3(0xe2ed4e15fc2290f11357bfcb0e07e1de86a97ef09005f81577c1ab301e0b06cc); /* statement */ \n_factory = IUniswapV2Factory(factory_);\r\nc_0xc019abf3(0x7699f304ac18d3f289ac0c85193ec2365b283316b7562bf9c295e8812484eccf); /* line */ \n        c_0xc019abf3(0x95aa70bd0d9ec058297fddec812f8b561a7b4a8ae337e9d85804997fea3b7529); /* statement */ \n_router = IUniswapV2Router02(router_);\r\nc_0xc019abf3(0x0e421407bd2469accc117d34ea5fafc622b4bff1f6880ed48b7b5681609e5de7); /* line */ \n        c_0xc019abf3(0xab5bbe41284a3b6957ce5c65951eb062887dec5f20c956b12a1ca803ff20f8e6); /* statement */ \nemit Initialized(_msgSender());\r\n    }\r\n\r\n    // ===== Swap Operations =====\r\n\r\n    /**\r\n     * @notice  IMPORTANT: amountOutMin parameter is the price to swap shortOptionTokens to underlyingTokens.\r\n     *          IMPORTANT: If the ratio between shortOptionTokens and underlyingTokens is 1:1, then only the swap fee (0.30%) has to be paid.\r\n     * @dev     Opens a longOptionToken position by minting long + short tokens, then selling the short tokens.\r\n     * @param   optionToken The option address.\r\n     * @param   amountOptions The quantity of longOptionTokens to purchase.\r\n     * @param   maxPremium The maximum quantity of underlyingTokens to pay for the optionTokens.\r\n     * @return  Whether or not the call succeeded.\r\n     */\r\n    function openFlashLong(\r\n        IOption optionToken,\r\n        uint256 amountOptions,\r\n        uint256 maxPremium\r\n    ) public override nonReentrant onlyRegistered(optionToken) returns (bool) {c_0xc019abf3(0x0b5ebf207e3a4cc701f924c5315a967d81019653008abaa333d4e74abbdced01); /* function */ \n\r\n        // Calls pair.swap(), and executes `flashMintShortOptionsThenSwap` in the `uniswapV2Callee` callback.\r\nc_0xc019abf3(0x506609ed6141d73fb3c82d37df3d0275bce013f9eb4cc589ad572a538ca266f5); /* line */ \n        c_0xc019abf3(0xe19f5679a534c9ac2c4297f81f1b05859d9264064bb83e59ab7c483bc6ff5cea); /* statement */ \n(IUniswapV2Pair pair, address underlying, ) = getOptionPair(optionToken);\r\nc_0xc019abf3(0xd8486d1add0b48ce7a09ff9e5b85848e8d801692c0cef505bb8fe34c3b4de0c0); /* line */ \n        c_0xc019abf3(0x156b5ca02bc660bc5da6c121d312625ff32371564bbd9c4141a6260d47b70477); /* statement */ \n_flashSwap(\r\n            pair, // Pair to flash swap from.\r\n            underlying, // Token to swap to, i.e. receive optimistically.\r\n            amountOptions, // Amount of underlying to optimistically receive to mint options with.\r\n            abi.encodeWithSelector( // Start: Function to call in the callback.\r\n                bytes4(\r\n                    keccak256(\r\n                        bytes(\"flashMintShortOptionsThenSwap(address,uint256,uint256)\")\r\n                    )\r\n                ),\r\n                optionToken, // Option token to mint with flash loaned tokens.\r\n                amountOptions, // Quantity of underlyingTokens from flash loan to use to mint options.\r\n                maxPremium // Total price paid (in underlyingTokens) for selling shortOptionTokens.\r\n            ) // End: Function to call in the callback.\r\n        );\r\nc_0xc019abf3(0xcd92d4884ea874da84fd7a66ed2888d64a74ef672a6ef32c87587bd89fa4eec9); /* line */ \n        c_0xc019abf3(0x654739d1ad0a6b5edfe2cb3bf2b5e9bead669280a86aa70ddf9d3ef361d0c57a); /* statement */ \nreturn true;\r\n    }\r\n\r\n    /**\r\n     * @notice  Executes the same as `openFlashLong`, but calls `permit` to pull underlying tokens.\r\n     */\r\n    function openFlashLongWithPermit(\r\n        IOption optionToken,\r\n        uint256 amountOptions,\r\n        uint256 maxPremium,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public override nonReentrant onlyRegistered(optionToken) returns (bool) {c_0xc019abf3(0xca6990cb1c1084aa170f0e0a411f8dcefb364cb6c85faac8bb4009158b1b0093); /* function */ \n\r\n        // Calls pair.swap(), and executes `flashMintShortOptionsThenSwap` in the `uniswapV2Callee` callback.\r\nc_0xc019abf3(0xc1b56d23fa2848c8659f3dc664cc86353ef6edcc08db2b9e3b24885d55489bf9); /* line */ \n        c_0xc019abf3(0x75ffa3d4368049d922e31ff600447f9ca4d0cdb2975663d71537562f9b143b10); /* statement */ \n(IUniswapV2Pair pair, address underlying, ) = getOptionPair(optionToken);\r\nc_0xc019abf3(0x714bbb71a9558e140679d530551d0674cf0e1a3dd1849c6f131a6bfe0e30f3ff); /* line */ \n        c_0xc019abf3(0xae44f3ea2c37024eaa525cb3dfab5e23a2cd02e08f8ebc9ab89cd1113495f231); /* statement */ \nIERC20Permit(underlying).permit(\r\n            getCaller(),\r\n            address(_primitiveRouter),\r\n            maxPremium,\r\n            deadline,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\nc_0xc019abf3(0xa42677c8edadfe9ff0c4cda9ff3419a22b9678f6b1520f21e759aaf56c58d48e); /* line */ \n        c_0xc019abf3(0x5c9649456dcb6c909126cc21644dfd6373d3dd54e70b2f64396e72bcfe141fe3); /* statement */ \n_flashSwap(\r\n            pair, // Pair to flash swap from.\r\n            underlying, // Token to swap to, i.e. receive optimistically.\r\n            amountOptions, // Amount of underlying to optimistically receive to mint options with.\r\n            abi.encodeWithSelector( // Start: Function to call in the callback.\r\n                bytes4(\r\n                    keccak256(\r\n                        bytes(\"flashMintShortOptionsThenSwap(address,uint256,uint256)\")\r\n                    )\r\n                ),\r\n                optionToken, // Option token to mint with flash loaned tokens.\r\n                amountOptions, // Quantity of underlyingTokens from flash loan to use to mint options.\r\n                maxPremium // Total price paid (in underlyingTokens) for selling shortOptionTokens.\r\n            ) // End: Function to call in the callback.\r\n        );\r\nc_0xc019abf3(0x0b9a83872e4f8319c581c1b3b0216e866f1cb96ffcfba25d49f545364ea84842); /* line */ \n        c_0xc019abf3(0x4a758bd132af235c70bfb4f70b7785df785b270efaad5414e8d6ea0b24ab87d1); /* statement */ \nreturn true;\r\n    }\r\n\r\n    /**\r\n     * @notice  Executes the same as `openFlashLongWithPermit`, but for DAI.\r\n     */\r\n    function openFlashLongWithDAIPermit(\r\n        IOption optionToken,\r\n        uint256 amountOptions,\r\n        uint256 maxPremium,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public override nonReentrant onlyRegistered(optionToken) returns (bool) {c_0xc019abf3(0x3c34448d2ecba90cc8af8877adf5d78dcc26fbb27a6bccbbf54ff3ecda19fe0b); /* function */ \n\r\n        // Calls pair.swap(), and executes `flashMintShortOptionsThenSwap` in the `uniswapV2Callee` callback.\r\nc_0xc019abf3(0x1e62879db53fa2fd22e50fc5e56e5e7df82a7f1d22e13c94d26fd06459e146cd); /* line */ \n        c_0xc019abf3(0xad53ba63de4fb14b609366b2568b79dbec9aae8f5ef90865851cadca435e986a); /* statement */ \n(IUniswapV2Pair pair, address underlying, ) = getOptionPair(optionToken);\r\nc_0xc019abf3(0x0f8957a5d45b34cd409f1a45375291ddbfd694364842c8fca4747a0a4a210ab4); /* line */ \n        c_0xc019abf3(0x8c733916b74c61902c7d137a0bbcddd7934e76a72fd9d363431c98701fc38fd7); /* statement */ \nDaiPermit(underlying).permit(\r\n            getCaller(),\r\n            address(_primitiveRouter),\r\n            IERC20Permit(underlying).nonces(getCaller()),\r\n            deadline,\r\n            true,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\nc_0xc019abf3(0xe892db643d53c66e69d57efb9f8fcee986ebae0193330b4260e768d9785841a7); /* line */ \n        c_0xc019abf3(0xfefcaa3f9c88fb655c23a919fec38d43198d72f75fc7561fecf1b4a86e0dba85); /* statement */ \n_flashSwap(\r\n            pair, // Pair to flash swap from.\r\n            underlying, // Token to swap to, i.e. receive optimistically.\r\n            amountOptions, // Amount of underlying to optimistically receive to mint options with.\r\n            abi.encodeWithSelector( // Start: Function to call in the callback.\r\n                bytes4(\r\n                    keccak256(\r\n                        bytes(\"flashMintShortOptionsThenSwap(address,uint256,uint256)\")\r\n                    )\r\n                ),\r\n                optionToken, // Option token to mint with flash loaned tokens.\r\n                amountOptions, // Quantity of underlyingTokens from flash loan to use to mint options.\r\n                maxPremium // Total price paid (in underlyingTokens) for selling shortOptionTokens.\r\n            ) // End: Function to call in the callback.\r\n        );\r\nc_0xc019abf3(0xe43db0fda3df13ef09c8f526f772b871c46ca59ee6bd35831084eb382d92e2d5); /* line */ \n        c_0xc019abf3(0x27b7e87db2764cc68bed9848053802ec72668220645c81fa590d657836ecf08a); /* statement */ \nreturn true;\r\n    }\r\n\r\n    /**\r\n     * @notice  Uses Ether to pay to purchase the option tokens.\r\n     *          IMPORTANT: amountOutMin parameter is the price to swap shortOptionTokens to underlyingTokens.\r\n     *          IMPORTANT: If the ratio between shortOptionTokens and underlyingTokens is 1:1, then only the swap fee (0.30%) has to be paid.\r\n     * @dev     Opens a longOptionToken position by minting long + short tokens, then selling the short tokens.\r\n     * @param   optionToken The option address.\r\n     * @param   amountOptions The quantity of longOptionTokens to purchase.\r\n     */\r\n    function openFlashLongWithETH(IOption optionToken, uint256 amountOptions)\r\n        external\r\n        payable\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(optionToken)\r\n        returns (bool)\r\n    {c_0xc019abf3(0xc3ae2e1a81d3b6d0816227469c39e94d732eb700e20eecfc05b7c99c440ab26b); /* function */ \n\r\nc_0xc019abf3(0x009ba825f19d9b704dc68e536c7d58c97a2d1858d3a4c3b8b1ec27b157461134); /* line */ \n        c_0xc019abf3(0x7d125740163c4effc9451b8ba10796637251910da6c9114579879007279401da); /* requirePre */ \nc_0xc019abf3(0xa9ffd7c573450c63cb26003256ad2e6e23dc7f050ef8b89ea3f9eccc684b0b35); /* statement */ \nrequire(msg.value > 0, \"PrimitiveSwaps: ZERO\");c_0xc019abf3(0x6abed15b3021efb9905b29bc5bc9e0eab5281d18f5a2d664213c3caec4b5f804); /* requirePost */ \n // Fail early if no Ether was sent.\r\n        // Calls pair.swap(), and executes `flashMintShortOptionsThenSwap` in the `uniswapV2Callee` callback.\r\nc_0xc019abf3(0xd466b2296019dbc544b105ea1febb9d4d14d8490d8030d03679dec0f94c6db6f); /* line */ \n        c_0xc019abf3(0x9d34baf6085102f9cc3ba6858c9d818656e7958ffe5a8225a5f75adebac6f79a); /* statement */ \n(IUniswapV2Pair pair, address underlying, ) = getOptionPair(optionToken);\r\nc_0xc019abf3(0x1de8c2152ed36a32b0b37b4a0057edf9a686b1d9b7d9b50580aac9d8f0d29622); /* line */ \n        c_0xc019abf3(0x6456fe8a310ebe6eec55e7cb4250665904e87176304146dd01a87dfa9c7d4f95); /* statement */ \n_flashSwap(\r\n            pair, // Pair to flash swap from.\r\n            underlying, // Token to swap to, i.e. receive optimistically.\r\n            amountOptions, // Amount of underlying to optimistically receive to mint options with.\r\n            abi.encodeWithSelector( // Start: Function to call in the callback.\r\n                bytes4(\r\n                    keccak256(\r\n                        bytes(\r\n                            \"flashMintShortOptionsThenSwapWithETH(address,uint256,uint256)\"\r\n                        )\r\n                    )\r\n                ),\r\n                optionToken, // Option token to mint with flash loaned tokens\r\n                amountOptions, // Quantity of underlyingTokens from flash loan to use to mint options.\r\n                msg.value // total price paid (in underlyingTokens) for selling shortOptionTokens.\r\n            ) // End: Function to call in the callback.\r\n        );\r\nc_0xc019abf3(0x559dde77e121e66616a325fc552767ed95491859f8a70abf694ca9abd9e5a8d4); /* line */ \n        c_0xc019abf3(0x34ae57df38e5633bd5f3695a8c4e8bd8e187d151e6af2ed5d7ea267cb08f4d53); /* statement */ \nreturn true;\r\n    }\r\n\r\n    /**\r\n     * @dev     Closes a longOptionToken position by flash swapping in redeemTokens,\r\n     *          closing the option, and paying back in underlyingTokens.\r\n     * @notice  IMPORTANT: If minPayout is 0, this function will cost the caller to close the option, for no gain.\r\n     * @param   optionToken The address of the longOptionTokens to close.\r\n     * @param   amountRedeems The quantity of redeemTokens to borrow to close the options.\r\n     * @param   minPayout The minimum payout of underlyingTokens sent out to the user.\r\n     */\r\n    function closeFlashLong(\r\n        IOption optionToken,\r\n        uint256 amountRedeems,\r\n        uint256 minPayout\r\n    ) external override nonReentrant onlyRegistered(optionToken) returns (bool) {c_0xc019abf3(0xfb37a9a93b658152b2820d6ab46c456ba1ccfcb57fc807f30553e56327683182); /* function */ \n\r\n        // Calls pair.swap(), and executes `flashCloseLongOptionsThenSwap` in the `uniswapV2Callee` callback.\r\nc_0xc019abf3(0x42a2223597c69a9262295880f19043d0ee9b30938fecfd0d3afa3da04a712aae); /* line */ \n        c_0xc019abf3(0x32650254dc3f26e38ea3dc78a4a5effc395452ab501ce81239f6708941f40cee); /* statement */ \n(IUniswapV2Pair pair, , address redeem) = getOptionPair(optionToken);\r\nc_0xc019abf3(0x976ed2059d0e8170ae8a618177a689326fa44a27011b4fe57a0d2089c93c64c4); /* line */ \n        c_0xc019abf3(0x8680c6a9e5740acd91ca20679ea538e7983c72f0136932035c48aaa8e27804e5); /* statement */ \n_flashSwap(\r\n            pair, // Pair to flash swap from.\r\n            redeem, // Token to swap to, i.e. receive optimistically.\r\n            amountRedeems, // Amount of underlying to optimistically receive to close options with.\r\n            abi.encodeWithSelector( // Start: Function to call in the callback.\r\n                bytes4(\r\n                    keccak256(\r\n                        bytes(\"flashCloseLongOptionsThenSwap(address,uint256,uint256)\")\r\n                    )\r\n                ),\r\n                optionToken, // Option token to close with flash loaned redeemTokens.\r\n                amountRedeems, // Quantity of redeemTokens from flash loan to use to close options.\r\n                minPayout // Total remaining underlyingTokens after flash loan is paid.\r\n            ) // End: Function to call in the callback.\r\n        );\r\nc_0xc019abf3(0x0a54727fae86edf92a18d9c17453cd25ad79a8c98f4b188e32dcfacd34a2af2d); /* line */ \n        c_0xc019abf3(0x7a08d6c06f06d2497e2fffaad904800c5c3b80fe73b32c5d1cdb249d51d10b9b); /* statement */ \nreturn true;\r\n    }\r\n\r\n    /**\r\n     * @dev     Closes a longOptionToken position by flash swapping in redeemTokens,\r\n     *          closing the option, and paying back in underlyingTokens.\r\n     * @notice  IMPORTANT: If minPayout is 0, this function will cost the caller to close the option, for no gain.\r\n     * @param   optionToken The address of the longOptionTokens to close.\r\n     * @param   amountRedeems The quantity of redeemTokens to borrow to close the options.\r\n     * @param   minPayout The minimum payout of underlyingTokens sent out to the user.\r\n     */\r\n    function closeFlashLongForETH(\r\n        IOption optionToken,\r\n        uint256 amountRedeems,\r\n        uint256 minPayout\r\n    ) external override nonReentrant onlyRegistered(optionToken) returns (bool) {c_0xc019abf3(0x050c7071b5141050c0103b6714d6ce275bfc76a02ab0f4620100873a1492df96); /* function */ \n\r\n        // Calls pair.swap(), and executes `flashCloseLongOptionsThenSwapForETH` in the `uniswapV2Callee` callback.\r\nc_0xc019abf3(0x30fcbcfb0de6551ca2bf30614e5a8ba55634dc2e4218e3366de8783275b002b2); /* line */ \n        c_0xc019abf3(0x244a2e9703795cc95b5d02628c9fa963bf7135db4d4acd3570e7f593fe9fe132); /* statement */ \n(IUniswapV2Pair pair, , address redeem) = getOptionPair(optionToken);\r\nc_0xc019abf3(0xfedc4dfb4268fe17e23b6c17228032798b1bf51ec167582f241ccf21828097fb); /* line */ \n        c_0xc019abf3(0xb7154e98438cd9dc9da47b5f3a45f2a5d8cd998cdfa4f5954d9d08e4a6ee4530); /* statement */ \n_flashSwap(\r\n            pair, // Pair to flash swap from.\r\n            redeem, // Token to swap to, i.e. receive optimistically.\r\n            amountRedeems, // Amount of underlying to optimistically receive to close options with.\r\n            abi.encodeWithSelector( // Start: Function to call in the callback.\r\n                bytes4(\r\n                    keccak256(\r\n                        bytes(\r\n                            \"flashCloseLongOptionsThenSwapForETH(address,uint256,uint256)\"\r\n                        )\r\n                    )\r\n                ),\r\n                optionToken, // Option token to close with flash loaned redeemTokens.\r\n                amountRedeems, // Quantity of redeemTokens from flash loan to use to close options.\r\n                minPayout // Total remaining underlyingTokens after flash loan is paid.\r\n            ) // End: Function to call in the callback.\r\n        );\r\nc_0xc019abf3(0x9267b88c25042fb14534b8cacff70dee2b4bac527b50fa0a15ecba4331c4490f); /* line */ \n        c_0xc019abf3(0x60fb498a9186639c4d1d646994d9dcac7dc4018040c428e64814e6503ff99e51); /* statement */ \nreturn true;\r\n    }\r\n\r\n    // ===== Flash Callback Functions =====\r\n\r\n    /**\r\n     * @notice  Callback function executed in a UniswapV2Pair.swap() call for `openFlashLong`.\r\n     * @dev     Pays underlying token `premium` for `quantity` of `optionAddress` tokens.\r\n     * @param   optionAddress The address of the Option contract.\r\n     * @param   quantity The quantity of options to mint using borrowed underlyingTokens.\r\n     * @param   maxPremium The maximum quantity of underlyingTokens to pay for the optionTokens.\r\n     * @return  Returns (amount, premium) of options purchased for total premium price.\r\n     */\r\n    function flashMintShortOptionsThenSwap(\r\n        address optionAddress,\r\n        uint256 quantity,\r\n        uint256 maxPremium\r\n    ) public onlySelf onlyRegistered(IOption(optionAddress)) returns (uint256, uint256) {c_0xc019abf3(0xd4704b6bedf1689e5299639aa920ad3802f65148979a4cd9db2824e6643ebf7e); /* function */ \n\r\nc_0xc019abf3(0x6017e2e136e36e595bc82a13a7e8182fcc8895411ea0048c9c0ffa37df82a439); /* line */ \n        c_0xc019abf3(0x1d1894e5ccb261882faf4005b16e975f7d23aa214882173584b1f7df2ffb750c); /* statement */ \nIOption optionToken = IOption(optionAddress);\r\nc_0xc019abf3(0xc407a051259ed7a8d65c472f5923c055a8cece8b4313c6850ab4fd4248c18757); /* line */ \n        c_0xc019abf3(0x8b15ed47d0c37f9964883f02734a56e85b7e2f86c78ec192915aa95cf00ccb3b); /* statement */ \n(IUniswapV2Pair pair, address underlying, address redeem) =\r\n            getOptionPair(optionToken);\r\n        // Mint option and redeem tokens to this contract.\r\nc_0xc019abf3(0x5db6174112f230e361256b7c6714d3d06cd809d9ffe190fdd494b0f80d6b58bf); /* line */ \n        c_0xc019abf3(0x24d25687f73a6b015cd2b3aafe6f14b2110f56e191e2f76fa191db2e8304e686); /* statement */ \n_mintOptions(optionToken);\r\n        // Get the repayment amounts.\r\nc_0xc019abf3(0x2767ef67e5cf6b414942c76b54b0b017b0128caf9da007ba8389ba93e157e868); /* line */ \n        c_0xc019abf3(0xd46b7406b60ce8f9d055d72a0ff126c5ec77e0f938b96880740c054c7bcf8ad3); /* statement */ \n(uint256 premium, uint256 redeemPremium) =\r\n            SwapsLib.repayOpen(_router, optionToken, quantity);\r\n        // If premium is non-zero and non-negative (most cases), send underlyingTokens to the pair as payment (premium).\r\nc_0xc019abf3(0xd74ab3155a75c38c3731cdc91414a125b43a38c8dffb400e8a880135edcc6b60); /* line */ \n        c_0xc019abf3(0xc99e8fc1ad11c11dd905814d759ccf47b433c39c4a8cb2fe057a33d24e0217ec); /* statement */ \nif (premium > 0) {c_0xc019abf3(0xfc2a590f803f77668655eaa388e1ada604415f2384e150296e7b345f81696168); /* branch */ \n\r\n            // Check for users to not pay over their max desired value.\r\nc_0xc019abf3(0x537fba565bde78c504e3c8a13a1bb8864e91bf21078705b8bbcb65c28c0cb942); /* line */ \n            c_0xc019abf3(0x3139f4e5829edfa4d0b1f023567af74d48c6fc7163148eb39e7924e50716d504); /* requirePre */ \nc_0xc019abf3(0x0e6bfb5e1f3dddd12746926d9a2c132795d3ec858289059938af315f96aca2c4); /* statement */ \nrequire(maxPremium >= premium, \"PrimitiveSwaps: MAX_PREMIUM\");c_0xc019abf3(0x5e421dcd50a7857c1bb5860f4341564343db34f274292d37ced295cc27fc061e); /* requirePost */ \n\r\n            // Pull underlyingTokens from the `getCaller()` to pay the remainder of the flash swap.\r\nc_0xc019abf3(0xd0a87892800980d578997cf3f6df7487076b29bb3891c6bc14b399d218c3ba23); /* line */ \n            c_0xc019abf3(0x6a56bc2a35a4d4eb022249de689db831a602ef1398754c17c9282a99dfb919ef); /* statement */ \n_transferFromCaller(underlying, premium);\r\n            // Push underlying tokens back to the pair as repayment.\r\nc_0xc019abf3(0xb1e59684460573057ba835a7bf0aa889c3385a6089ac6e9f28cb72fadde77e21); /* line */ \n            c_0xc019abf3(0x46d8ca4d093f2c782d761ebf63513c22e88e35c27831026f861272c93967a625); /* statement */ \nIERC20(underlying).safeTransfer(address(pair), premium);\r\n        }else { c_0xc019abf3(0x1cd401494b6daac75b3ca3a3462b16df11f21872624fa79b774ca875535b0dce); /* branch */ \n}\r\n        // Pay pair in redeem tokens.\r\nc_0xc019abf3(0xb12e195da5685d735c1a098cf3941a23a40806f86638d3747d0e9e22b845773d); /* line */ \n        c_0xc019abf3(0xaf3afdc7ebbf7d8e972a9a1c9a2ab3edee7d01f05275b2dfebf9c7bd7cd81f10); /* statement */ \nif (redeemPremium > 0) {c_0xc019abf3(0x93a4a1ba23e3d432a666a66a21a174c2ae45f080696bb7a4796d079c4b464815); /* branch */ \n\r\nc_0xc019abf3(0x84166c370a34797f31362e574a159fb26499460776755d606137bbd2fd86b0da); /* line */ \n            c_0xc019abf3(0xf06096b7955f4d03ac69338953e58f00c08bb12b406a1d66608c08d134a4e3f0); /* statement */ \nIERC20(redeem).safeTransfer(address(pair), redeemPremium);\r\n        }else { c_0xc019abf3(0x679b1359972a854522121b0072c75d9a4cacdc641ede988c8d86c21a2ce26cbf); /* branch */ \n}\r\n        // Return tokens to `getCaller()`.\r\nc_0xc019abf3(0xa634e9d4330eb961c4947c388e4fb8c6e13e0063ac8eb718f0258e9cff6a5704); /* line */ \n        c_0xc019abf3(0x7654070545ced2c184af8bf1a5e1445be3b6dc475b02ac861e3bd188097fb868); /* statement */ \n_transferToCaller(redeem);\r\nc_0xc019abf3(0x1a0a868cce567425b138d0ca4c6bee30da493c21d71588bccf208f22efe8a6fc); /* line */ \n        c_0xc019abf3(0x8101c1738f7d17ca927020765a0250e20ed63c15bbd1e8165686ba8417bd5060); /* statement */ \n_transferToCaller(optionAddress);\r\nc_0xc019abf3(0xb3b98dd4cad26915f84a73e9c8687496439667e4cc60be4c3bc9381f2f8efc5b); /* line */ \n        c_0xc019abf3(0xee33a1698fe14887c4cc59ca34e5fa984c52156452ff73b9b0d1059da0fd411e); /* statement */ \nemit Buy(getCaller(), optionAddress, quantity, premium);\r\nc_0xc019abf3(0x456aa32f4279c4b54342ab43b7162dff98f370626f03f6a0b8ec69428f75ca3d); /* line */ \n        c_0xc019abf3(0x20b76abd59a42d59171f74919cada63c2fa0666df0932fbae2cc450be0c50245); /* statement */ \nreturn (quantity, premium);\r\n    }\r\n\r\n    /**\r\n     * @notice  Callback function executed in a UniswapV2Pair.swap() call for `openFlashLongWithETH`.\r\n     * @dev     Pays `premium` in ether for `quantity` of `optionAddress` tokens.\r\n     * @param   optionAddress The address of the Option contract.\r\n     * @param   quantity The quantity of options to mint using borrowed underlyingTokens.\r\n     * @param   maxPremium The maximum quantity of underlyingTokens to pay for the optionTokens.\r\n     * @return  Returns (amount, premium) of options purchased for total premium price.\r\n     */\r\n    function flashMintShortOptionsThenSwapWithETH(\r\n        address optionAddress,\r\n        uint256 quantity,\r\n        uint256 maxPremium\r\n    ) public onlySelf onlyRegistered(IOption(optionAddress)) returns (uint256, uint256) {c_0xc019abf3(0x1956a1b3e77f0cf527dfb7c6173a40d0b0fd400397d0d19768ca399ade4bd487); /* function */ \n\r\nc_0xc019abf3(0x78bd81ece4e3336f8abb8bb6ce6923473639a95fbe0840ff7bf65bcce04cc53c); /* line */ \n        c_0xc019abf3(0xd34a98fb54bbbc70d21456893f4d134e343ecac8b310bd1bb820397c1be7c78e); /* statement */ \nIOption optionToken = IOption(optionAddress);\r\nc_0xc019abf3(0xc94063bbf3cb4c182ef99a1a0e663b34b1e27f75b96180cfa5ba9d3926bbeb61); /* line */ \n        c_0xc019abf3(0xed216d88d77d691d3918b8cd7480c53ef38a8d246224b56911790f2d06c94f91); /* statement */ \n(IUniswapV2Pair pair, address underlying, address redeem) =\r\n            getOptionPair(optionToken);\r\nc_0xc019abf3(0x37788f8f6fd5a8fafb5ba9d20802abdef8c975795a265c5c9fd3c9287f75528b); /* line */ \n        c_0xc019abf3(0xccff5d74127ed95ebf467b1c4c715cdd5cc1ca5ddfe28dc9316bef4d888ff36d); /* requirePre */ \nc_0xc019abf3(0x61376c1aeb62d4c13bd6d46e457a35c18ec513021d9778aa32998b6830c41b3e); /* statement */ \nrequire(underlying == address(_weth), \"PrimitiveSwaps: NOT_WETH\");c_0xc019abf3(0x02eea968bd2ce633cf86d3b34ad8ea44aa919edc157d1fa4708500fd09385675); /* requirePost */ \n // Ensure Weth Call.\r\n        // Mint option and redeem tokens to this contract.\r\nc_0xc019abf3(0x9b7080d359f70d42f9405aad97a7156edc998eba2dc778e059c008de1959ff84); /* line */ \n        c_0xc019abf3(0x9b0be9bac7c84c66124dc6563098e511c3d540408dd274f0a6d636e9653b9878); /* statement */ \n_mintOptions(optionToken);\r\n        // Get the repayment amounts.\r\nc_0xc019abf3(0xdb053f0933c7bc48fc85a6386a0c9fea6d1e6f4950eb6310da88e31bcde1779b); /* line */ \n        c_0xc019abf3(0x643dc21a68cd356f97f8460c23e36965dbe732d41f20814f465e93224071a5c7); /* statement */ \n(uint256 premium, uint256 redeemPremium) =\r\n            SwapsLib.repayOpen(_router, optionToken, quantity);\r\n        // If premium is non-zero and non-negative (most cases), send underlyingTokens to the pair as payment (premium).\r\nc_0xc019abf3(0x00c21cd892bf750eb0246946a46e96ef6a29c95e4414e739d3804006891c77fc); /* line */ \n        c_0xc019abf3(0x80f9c4061b9e05d4cc2cc9d47b7e46dd83ea4838f133b1c709deb5c18bd543a4); /* statement */ \nif (premium > 0) {c_0xc019abf3(0xd72aff55cb589a98443f75745f69260b89d7206f5511d2e1e033939b01c7ec4b); /* branch */ \n\r\n            // Check for users to not pay over their max desired value.\r\nc_0xc019abf3(0x0a81d4311821d2123057f5beb829ad24a82047a25244e5b115f5a44cd8bda700); /* line */ \n            c_0xc019abf3(0x8d8ee72a36849a29ee8736986a9e4ae27a9976bae71e3b37f21a9d1071af162b); /* requirePre */ \nc_0xc019abf3(0x48e42d27119545ecc1d450d0fbe5a5db723963d631637bf785f8ea1addb37c1d); /* statement */ \nrequire(maxPremium >= premium, \"PrimitiveSwaps: MAX_PREMIUM\");c_0xc019abf3(0xb9e0c007c6564779b5d3e039dd13081fea219f981ca30af27c733cad0451770e); /* requirePost */ \n\r\n            // Wrap exact Ether amount of `premium`.\r\nc_0xc019abf3(0x149c9929a46b3b5c0300cba913e87fd7dd2be5c25c1a4bc44e32e1386378aea0); /* line */ \n            c_0xc019abf3(0x51d7420a8f259f3ee7130ed848c9134609fd6dd17ccbb0d398513e9ef0354a6e); /* statement */ \n_weth.deposit.value(premium)();\r\n            // Transfer Weth to pair to pay for premium.\r\nc_0xc019abf3(0xc21eed20fc1af3db3099d6de7534790999acfe00180545dc6d024ec47cb7c2db); /* line */ \n            c_0xc019abf3(0xe0339d34d15196a4e517b01586bb01a23a153e259d269bec76fb676e47925061); /* statement */ \nIERC20(address(_weth)).safeTransfer(address(pair), premium);\r\n            // Return remaining Ether to caller.\r\nc_0xc019abf3(0x68f65db1dff34f291adc9656c3defda5e27b184e11738942849534765507af23); /* line */ \n            c_0xc019abf3(0xa7513218715bfa6d592f9fe6812aba95a9417e80bdf7ae5e1ab8617be48110e3); /* statement */ \n_withdrawETH();\r\n        }else { c_0xc019abf3(0xad4d95cd06ff89a63c62aa14e3281bce10cf55bd07caad64eae30bc99fa715f4); /* branch */ \n}\r\n        // Pay pair in redeem.\r\nc_0xc019abf3(0x5b3aa3304a119c6e575916c55856901167517b3cbf93666782a665ab00ca30cf); /* line */ \n        c_0xc019abf3(0x17fabd41d270ebb22ab7871dcd72bad25624a8731c6a739d8e9935bf5a03b573); /* statement */ \nif (redeemPremium > 0) {c_0xc019abf3(0x29dda7144d9f907a8aa14417cf82fd9bbc842a8cb1530107cf9315eae4dc3662); /* branch */ \n\r\nc_0xc019abf3(0x5b52312e049b089c5bfbe0732e697acddac70dd7fe028263e9088993002d083b); /* line */ \n            c_0xc019abf3(0x83e0b6bb2717f7e9cc98038c0599c73bc40e4b77995b031b2adf1c57488f45c7); /* statement */ \nIERC20(redeem).safeTransfer(address(pair), redeemPremium);\r\n        }else { c_0xc019abf3(0x22c05eab222d3703ba9eb85b7fdbe0f59fbececf90e59d5ef57898d86b944611); /* branch */ \n}\r\n        // Return tokens to `getCaller()`.\r\nc_0xc019abf3(0x850af133a22738639cac40c4fe78081068405afedb6e94ef638ff9ef6ee23c68); /* line */ \n        c_0xc019abf3(0x630e38e9a864df7c15c63972162f56732b112af9587546dc7d1103c286171bda); /* statement */ \n_transferToCaller(redeem);\r\nc_0xc019abf3(0xe64c9bcf6907cb156905ec1b247de3378482b220f519d1e837f285554072c2d7); /* line */ \n        c_0xc019abf3(0xf6b21bf7bfd5b4a8d8a5cbcfbab0f04fde50957f28c12d5b1195bbd683867f98); /* statement */ \n_transferToCaller(optionAddress);\r\nc_0xc019abf3(0x47d52a77f3062856f9f848f12c9a4d5266fa764110876268f516b9339408c946); /* line */ \n        c_0xc019abf3(0xce41c00d5a0b08594dba9039cee5cf33df073e2c2999ac17cc2ebc5fb73e4aa5); /* statement */ \nemit Buy(getCaller(), optionAddress, quantity, premium);\r\nc_0xc019abf3(0xce2d1073f7307e9b3fe5516c86d3e9f9a163d9a97a0c4373edcebad6129bda04); /* line */ \n        c_0xc019abf3(0x5a31a2596f0be6227c7da68e802f53a1dbe320d80e85978f673a91155adc98cb); /* statement */ \nreturn (quantity, premium);\r\n    }\r\n\r\n    /**\r\n     * @dev     Sends shortOptionTokens to _msgSender(), and pays back the UniswapV2Pair in underlyingTokens.\r\n     * @notice  IMPORTANT: If minPayout is 0, the `to` address is liable for negative payouts *if* that occurs.\r\n     * @param   optionAddress The address of the longOptionTokes to close.\r\n     * @param   flashLoanQuantity The quantity of shortOptionTokens borrowed to use to close longOptionTokens.\r\n     * @param   minPayout The minimum payout of underlyingTokens sent to the `to` address.\r\n     */\r\n    function flashCloseLongOptionsThenSwap(\r\n        address optionAddress,\r\n        uint256 flashLoanQuantity,\r\n        uint256 minPayout\r\n    ) public onlySelf onlyRegistered(IOption(optionAddress)) returns (uint256, uint256) {c_0xc019abf3(0xc3527fd7725fc17244958b15074fc462bc1c4d34071eb095dc7c919ff29e5205); /* function */ \n\r\nc_0xc019abf3(0xf3d9f1fa452c4cad882ac99e85101b670b964791f21b583b965518ad1056f0e6); /* line */ \n        c_0xc019abf3(0xca198c33c999afd7df6d33e1cc8c624ecf21ff7f6dba1c3033f7644e2d3f373c); /* statement */ \nIOption optionToken = IOption(optionAddress);\r\nc_0xc019abf3(0x227604a9fb2e4e9cddf820ca08734fcc5e24b0a23839dd0ce62ee5c9d30cc7d0); /* line */ \n        c_0xc019abf3(0x09e7ef79d5c20d067b6bd2e9a1828ccd5673fd92c00675d9495a874f2a52c224); /* statement */ \n(IUniswapV2Pair pair, address underlying, address redeem) =\r\n            getOptionPair(optionToken);\r\n        // Close the options, releasing underlying tokens to this contract.\r\nc_0xc019abf3(0xa5418f61be5233753de695699352e0f73d0cb20e6b80ab589252f1f8c4839395); /* line */ \n        c_0xc019abf3(0xbc172f50df20d1084fdfe24cd5b23fa35ef71978aebd6c21479fa040e4bd53d1); /* statement */ \nuint256 outputUnderlyings = _closeOptions(optionToken);\r\n        // Get repay amounts.\r\nc_0xc019abf3(0x5dbfce0797efc3b58a21572fda2b289ed4e2c41c9c0d1b7823bf9f206268743e); /* line */ \n        c_0xc019abf3(0xeb4686b385dc6d251a891c61cba0e06002f7ec4b43a80d8a74acc61f125ef6d8); /* statement */ \n(uint256 payout, uint256 cost, uint256 outstanding) =\r\n            SwapsLib.repayClose(_router, optionToken, flashLoanQuantity);\r\nc_0xc019abf3(0xa921743487fef04dfc4f59c48f46e7de70f6852c739a290ffc5376b1144dd9f4); /* line */ \n        c_0xc019abf3(0xfd90fa86edb9da0daf2875376d8b81850551c5d56ca1cadca0db87061be19ab8); /* statement */ \nif (payout > 0) {c_0xc019abf3(0xfc27380936e621e0c675a3f850f09447ab2f164d613e978f61916246fe46f171); /* branch */ \n\r\nc_0xc019abf3(0xb4ad145442e9c969000cce5f49c5f94051a74b6c555b49b3b076647addb7eaf8); /* line */ \n            c_0xc019abf3(0x78cb16d2728b00f5d0b701b6318862640ff7d19ac569824b77ac0a558d8ef497); /* statement */ \ncost = outputUnderlyings.sub(payout);\r\n        }else { c_0xc019abf3(0x30f10f8e13ee7ed4d0e634acd96ce13ccaadcb8dec985aba75bfc0b18f89f23c); /* branch */ \n}\r\n        // Pay back the pair in underlyingTokens.\r\nc_0xc019abf3(0x81472b89c3e1b64f4ab71c9a1d58535e9e24ceb4865cdb65f897927e824e45a3); /* line */ \n        c_0xc019abf3(0x4b2e88bb7c1e24355da83706ba87296fbc3aacef5df6520b6b3548c3ae2230f8); /* statement */ \nif (cost > 0) {c_0xc019abf3(0x1289d016e6be8f7d3ed6c5e26049134be7830a81571aa0c7a03377af493e0fcc); /* branch */ \n\r\nc_0xc019abf3(0x70dd86098daad2b70ca9cdc6a67d81df05168d5aecda6bee571e112a0ba7618d); /* line */ \n            c_0xc019abf3(0xa2f99fdb0ba28560c7d14f395c73e187d1653bf1021aaf6a07dabc547fe91108); /* statement */ \nIERC20(underlying).safeTransfer(address(pair), cost);\r\n        }else { c_0xc019abf3(0x76969578eb1098ea39e5c7f85552f645bcbfc889907bfd071809336140f475b8); /* branch */ \n}\r\nc_0xc019abf3(0xd712a71202d3ba8f45805e4ac4eaf2288bfc65d40ec2fef2e20d66da3690a22c); /* line */ \n        c_0xc019abf3(0x39231d671e09899a6fbb4fa30f9200e682132b49d9721892da42fb0d0578c4c9); /* statement */ \nif (outstanding > 0) {c_0xc019abf3(0xec7c360d6b9ad6806e4325b2c700af5400facdec5546e8361a9bf5142ef5cb25); /* branch */ \n\r\n            // Pull underlyingTokens from the `getCaller()` to pay the remainder of the flash swap.\r\n            // Revert if the minPayout is less than or equal to the underlyingPayment of 0.\r\n            // There is 0 underlyingPayment in the case that outstanding > 0.\r\n            // This code branch can be successful by setting `minPayout` to 0.\r\n            // This means the user is willing to pay to close the position.\r\nc_0xc019abf3(0xa074a7311f8ab8d0b7c6e71bb40439fe21c9b4e7b9d5951cb671e88ba9253e2a); /* line */ \n            c_0xc019abf3(0x1b0005fa412c1df180bf1897ccb12a38c98c146af9fa0a6e78f9d75982a89b25); /* requirePre */ \nc_0xc019abf3(0xa2d5fed3c99d833448d2e03fd273204bd696b49fc18458c17d62e3e1701f6d17); /* statement */ \nrequire(minPayout <= payout, \"PrimitiveSwaps: NEGATIVE_PAYOUT\");c_0xc019abf3(0x4dcdee23fb751651c502ad4b38b1ae4ef41dacfa1a71f10612c7bc7f5e905178); /* requirePost */ \n\r\nc_0xc019abf3(0x4c4fdacb218b5c1dc7b4ebf0f659bfd3801e758865ed1fc49174485271333897); /* line */ \n            c_0xc019abf3(0xa4432f641cc8a19b11f44bf7f55eae0e6960a457ad0f7bdb92a722b4ff68ac4a); /* statement */ \n_transferFromCallerToReceiver(underlying, outstanding, address(pair));\r\n        }else { c_0xc019abf3(0x49159dfd3befb87866943b6b62d6d80f7c6628d79bd01a0712cd792da8af6532); /* branch */ \n}\r\n        // If payout is non-zero and non-negative, send it to the `getCaller()` address.\r\nc_0xc019abf3(0xd31d9dd36d40332a305c21028615c7c6829871c4c9d78bb30d18c47bbef8daa1); /* line */ \n        c_0xc019abf3(0x7d198fbf3e44a497773a42900fde34557e994c197cb56ac3e006d21af727d3f6); /* statement */ \nif (payout > 0) {c_0xc019abf3(0x3656548e30e92314f95412085c206cc7359bf7964a58985de339ff8b9a501db7); /* branch */ \n\r\n            // Revert if minPayout is greater than the actual payout.\r\nc_0xc019abf3(0x7118b7436bb49c4a1f88bef6535dfe3f49ac142cebca2c3d388c4736f9892756); /* line */ \n            c_0xc019abf3(0x486acd4dd88592099b4a22bc7bb95c8e206fa0a727c447293a110dd478701296); /* requirePre */ \nc_0xc019abf3(0x6e0cf8bcc9f5e76fdd7146f3f44d1f8f41666613a3b0fa0b3846a6d90242afe3); /* statement */ \nrequire(payout >= minPayout, \"PrimitiveSwaps: MIN_PREMIUM\");c_0xc019abf3(0x63eb1e109cfb5d9dc4a52732eeadcc34954aaf8be057ed30fb287d414f7b1c5e); /* requirePost */ \n\r\nc_0xc019abf3(0xe9bdc51b6c20d41fbdf0a491f63784ad2874bfe9288f1eb5d3c1c6ac9164e5c1); /* line */ \n            c_0xc019abf3(0x0da883773adc7b3eadc6d46a57bb1f6269a76b3bd8f50c62960cd3ab2ec2cfd6); /* statement */ \n_transferToCaller(underlying);\r\n        }else { c_0xc019abf3(0xdf2906321f65cb1e4b6df307ce91c54e2210d705453c392910f5d812f2aa1829); /* branch */ \n}\r\nc_0xc019abf3(0x3e70b798aabaae810496553f32ddb9b1547aa04adf2fa4730f1e51c6ba8be8fa); /* line */ \n        c_0xc019abf3(0xfaceaa262200954776d9b9b93ce2cf8ffb20b5b0ada06c4068ea362135ffaba8); /* statement */ \nemit Sell(getCaller(), optionAddress, flashLoanQuantity, payout);\r\nc_0xc019abf3(0x7a53080e3f16691060138611392c0c34008dc55f8b44dadbdb65d8a596ea56df); /* line */ \n        c_0xc019abf3(0xf215830c5c66a688c05350f2865ce7b89740428f8e11390d4f16ba5f395ab47e); /* statement */ \nreturn (payout, cost);\r\n    }\r\n\r\n    /**\r\n     * @dev     Sends shortOptionTokens to _msgSender(), and pays back the UniswapV2Pair in underlyingTokens.\r\n     * @notice  IMPORTANT: If minPayout is 0, the `getCaller()` address is liable for negative payouts *if* that occurs.\r\n     * @param   optionAddress The address of the longOptionTokes to close.\r\n     * @param   flashLoanQuantity The quantity of shortOptionTokens borrowed to use to close longOptionTokens.\r\n     * @param   minPayout The minimum payout of underlyingTokens sent to the `to` address.\r\n     */\r\n    function flashCloseLongOptionsThenSwapForETH(\r\n        address optionAddress,\r\n        uint256 flashLoanQuantity,\r\n        uint256 minPayout\r\n    ) public onlySelf onlyRegistered(IOption(optionAddress)) returns (uint256, uint256) {c_0xc019abf3(0x8a8afc5341a6d7c9039fcb91c5497f90de003b1a012c7bc083eeb146e487d38c); /* function */ \n\r\nc_0xc019abf3(0xf4198b7acec669b9de40575f07bff5f6ab245bd3d23e59114b0a9bebdcb84d65); /* line */ \n        c_0xc019abf3(0xf7653924850a9575c0369b02b8038d95269afc7aaae2109e9c5773e0248c620c); /* statement */ \nIOption optionToken = IOption(optionAddress);\r\nc_0xc019abf3(0x7d70c47250c5a98d62b69ce1ea4508edb04f4b754ccce12036dafd4ee8ce8f2c); /* line */ \n        c_0xc019abf3(0x52065a42adcfe92259a3fdfc8c0e738efc67ca3dc52e526086aabc1a4c8fc895); /* statement */ \n(IUniswapV2Pair pair, address underlying, address redeem) =\r\n            getOptionPair(optionToken);\r\nc_0xc019abf3(0xcc71e786626ac9faa4e727544fea425015a888ba2ae0faecb1531ce067b166be); /* line */ \n        c_0xc019abf3(0xe08d35f4f32850284cb37d68c08926991c1264277bd1956fea6507e083cceaa1); /* requirePre */ \nc_0xc019abf3(0x3a7d5a648cc7dc93778c54700275f23c61fa213c257e4882e9dbced392b63a3d); /* statement */ \nrequire(underlying == address(_weth), \"PrimitiveSwaps: NOT_WETH\");c_0xc019abf3(0x25ba0798b5d21b7dd2dcf4d5e9834bcb8e37bc823f4affee282c5f3aa1deaa67); /* requirePost */ \n\r\n        // Close the options, releasing underlying tokens to this contract.\r\nc_0xc019abf3(0x07b438c08e350bfdad80ca09b7b082ba646458c9521fdd9b657f570eb134fe8a); /* line */ \n        c_0xc019abf3(0xbe591b2d2d13be937d16505067864b5087c4eb15abc5cfad7c48257c4a4dc7dd); /* statement */ \n_closeOptions(optionToken);\r\n        // Get repay amounts.\r\nc_0xc019abf3(0xf3e51152e9999d7b3c86815099ee583db82e5e43a8e5252fb15a4948e0edfd0c); /* line */ \n        c_0xc019abf3(0x6c20039bc1feda7c2b6881ccc16d73a5708c9cca674d91b12261c1ce200015fd); /* statement */ \n(uint256 payout, uint256 cost, uint256 outstanding) =\r\n            SwapsLib.repayClose(_router, optionToken, flashLoanQuantity);\r\n        // Pay back the pair in underlyingTokens.\r\nc_0xc019abf3(0x3a9b610d2b1fb005190a28332f48dc8aabdba089188a3e4d17facdf75a71f782); /* line */ \n        c_0xc019abf3(0x86be245c6228cb9bc35f52d7af49aba86aab650c3d444a879584498a702daaef); /* statement */ \nif (cost > 0) {c_0xc019abf3(0x9eb8645564db84b516aab22d7d6696048b12c5f1e68d1af9c503068be2ef0cd5); /* branch */ \n\r\nc_0xc019abf3(0x79f6ad0fb1a6c0455f2d6a3136e64cd516223360ef4b68e981932243119612a9); /* line */ \n            c_0xc019abf3(0x1eb057a12b248bd741e07d69723dfafdcdc84994c1288358044dceffb3e99e1d); /* statement */ \nIERC20(underlying).safeTransfer(address(pair), cost);\r\n        }else { c_0xc019abf3(0xd680f48f376068ccd464cd43bedac74cebcc5d80bcf8ba435b354258c9c473cc); /* branch */ \n}\r\nc_0xc019abf3(0xfde7aebc4d62203eb249a7b2e7eab50dc1d024bfba6c56cd025805376a0ae82d); /* line */ \n        c_0xc019abf3(0x3ed49b514de9cbb445b8c615903cf68294f8ed47afaad0166a3ed2aa0622c8a1); /* statement */ \nif (outstanding > 0) {c_0xc019abf3(0xae9b174176f84eb211baba5fb0827bb93a845f2a7673184b9a9fed6b9a90ab3d); /* branch */ \n\r\n            // Pull underlyingTokens from the `getCaller()` to pay the remainder of the flash swap.\r\n            // Revert if the minPayout is less than or equal to the underlyingPayment of 0.\r\n            // There is 0 underlyingPayment in the case that outstanding > 0.\r\n            // This code branch can be successful by setting `minPayout` to 0.\r\n            // This means the user is willing to pay to close the position.\r\nc_0xc019abf3(0x0e77b3a822f34c644cd09585301b334bf17e09bf39f7d6e9ff3a32177e7a3303); /* line */ \n            c_0xc019abf3(0x2cbb81eab4bc450e5ff27cba2588acfd9d5d4188a76ce36bf742376954133aa6); /* requirePre */ \nc_0xc019abf3(0xb7e4612e5133ba45f14aace41eda7bb3386bb363c1c03631c4ab897aae9d3147); /* statement */ \nrequire(minPayout <= payout, \"PrimitiveSwaps: NEGATIVE_PAYOUT\");c_0xc019abf3(0xb5b3ba1c06197d5ac57e015697a3462295e59594a057a26a6a028c81f49fddff); /* requirePost */ \n\r\nc_0xc019abf3(0x69bd39146b7c99f3b34f45fa77f1f009d06072947570d0f57e53a014fcf9ea15); /* line */ \n            c_0xc019abf3(0x76e0f53cc1db70d5fee883993ebe52505febe0a8352af0fe005b72917d57e469); /* statement */ \n_transferFromCallerToReceiver(underlying, outstanding, address(pair));\r\n        }else { c_0xc019abf3(0x8ae59228dda9088d9060a98852bb7ff3798f473d7e9970c06dcc90df90c9cac1); /* branch */ \n}\r\n        // If payout is non-zero and non-negative, send it to the `getCaller()` address.\r\nc_0xc019abf3(0xa40f9ad0c99d764cf938519e766f5771bf81035fe2884f444692d75ac85d66d2); /* line */ \n        c_0xc019abf3(0xf99191b2f0e12aeea1f7995c590f7ba5b8cc56202a076b9e29f5800c88b4f4e1); /* statement */ \nif (payout > 0) {c_0xc019abf3(0xfa29e36e7182c66448e07134bbdbc137ed08988c2343247bf8663d54a059c061); /* branch */ \n\r\n            // Revert if minPayout is greater than the actual payout.\r\nc_0xc019abf3(0xe186a7f25bcf14def279f19539e4034419c644ab99d539eaf486ea64db64a094); /* line */ \n            c_0xc019abf3(0x45ac170a58b6d03892da1caba5a6779b36ba9c12ae9ca4907d923e22683d7f5b); /* requirePre */ \nc_0xc019abf3(0xffbec8734e5a5a5b818baad751ee2516916f5ea4031e09ff6937363e4a5474ee); /* statement */ \nrequire(payout >= minPayout, \"PrimitiveSwaps: MIN_PREMIUM\");c_0xc019abf3(0xfed460bf2506f9dfc6eb33a1c57323f79da1e63e10e80b2f1edbff45f9467158); /* requirePost */ \n\r\nc_0xc019abf3(0xd1ca5df472a4af2f4ba03bc0d0b5acb5d097e72206ecfc66fbf51d9ae189cf5c); /* line */ \n            c_0xc019abf3(0x162b93991102999cd8e2737b2fd6c6779e0763bc8a1609b86a1e62e98866ad93); /* statement */ \n_withdrawETH(); // Unwrap's this contract's balance of Weth and sends Ether to `getCaller()`.\r\n        }else { c_0xc019abf3(0x5efa79bfc2375a93569ceb181fa8d7b6f91d52c13d769c98162099f4441fc7e0); /* branch */ \n}\r\nc_0xc019abf3(0x7e0dd12e304063f14c3295e87ddaf39d5218028e929e2d096450c43a83c602e9); /* line */ \n        c_0xc019abf3(0x7c1e967de02f579aea650fbd1cac4b259de29d79a9a994fcf61b4767ec318a90); /* statement */ \nemit Sell(getCaller(), optionAddress, flashLoanQuantity, payout);\r\nc_0xc019abf3(0xea287682f22b40027a2957ced3345e1d510c848e7dbd884bf2774662e96f5159); /* line */ \n        c_0xc019abf3(0x5928173e8fd120cc13cfed7fe1c126079faab1a075ba53bde9d43067d346da91); /* statement */ \nreturn (payout, cost);\r\n    }\r\n\r\n    // ===== Flash Loans =====\r\n\r\n    /**\r\n     * @notice  Passes in `params` to the UniswapV2Pair.swap() function to trigger the callback.\r\n     * @param   pair The Uniswap Pair to call.\r\n     * @param   token The token in the Pair to swap to, and thus optimistically receive.\r\n     * @param   amount The quantity of `token`s to optimistically receive first.\r\n     * @param   params  The data to call from this contract, using the `uniswapV2Callee` callback.\r\n     * @return  Whether or not the swap() call suceeded.\r\n     */\r\n    function _flashSwap(\r\n        IUniswapV2Pair pair,\r\n        address token,\r\n        uint256 amount,\r\n        bytes memory params\r\n    ) internal returns (bool) {c_0xc019abf3(0x0de4df7d14e525c0008f68fd73c3a8113a822621d31b66c8e0a341030a684a0c); /* function */ \n\r\n        // Receives `amount` of `token` to this contract address.\r\nc_0xc019abf3(0x86b7411da55440ba399aad72606c310d228c2ec168406352dce9e00e53d41eb4); /* line */ \n        c_0xc019abf3(0xc8bff10835c0752d4da8c987db81172c18352d6b8de7026b51b14a04a5197185); /* statement */ \nuint256 amount0Out = pair.token0() == token ? amount : 0;\r\nc_0xc019abf3(0xda0da6a272c123c72f5bf45bdbba50685b5b376d46c2b44e2bef89bce4d0be0d); /* line */ \n        c_0xc019abf3(0xce6e41ff3183236eff1392038343c5586fec0e9ea9a5d21604e0016561c1e6c6); /* statement */ \nuint256 amount1Out = pair.token0() == token ? 0 : amount;\r\n        // Execute the callback function in params.\r\nc_0xc019abf3(0x3249af94e9cb1a95599923334b108bd8bd1fc859792d197d189d2bc6f480c1ec); /* line */ \n        c_0xc019abf3(0xe5933352b9a4885accee9cbc97a65c70d23e76aedc90b9e53f7506605cfecc09); /* statement */ \npair.swap(amount0Out, amount1Out, address(this), params);\r\nc_0xc019abf3(0x98ac32126966b82e57532c1dfdb32a81cb94c2d456e5a943de2f0767ce8ea553); /* line */ \n        c_0xc019abf3(0xf9b90ac06d23851c60b862d0086a8fe789f8050552551633a62dbd46c1001254); /* statement */ \nreturn true;\r\n    }\r\n\r\n    /**\r\n     * @dev     The callback function triggered in a UniswapV2Pair.swap() call when the `data` parameter has data.\r\n     * @param   sender The original _msgSender() of the UniswapV2Pair.swap() call.\r\n     * @param   amount0 The quantity of token0 received to the `to` address in the swap() call.\r\n     * @param   amount1 The quantity of token1 received to the `to` address in the swap() call.\r\n     * @param   data The payload passed in the `data` parameter of the swap() call.\r\n     */\r\n    function uniswapV2Call(\r\n        address sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        bytes calldata data\r\n    ) external override(IPrimitiveSwaps, IUniswapV2Callee) {c_0xc019abf3(0x0685249db9e8cb56ec2dd65994f86badd75fec32a6ca99520b6a7c5e15aabc72); /* function */ \n\r\nc_0xc019abf3(0x3d80f8e6a9b068d3429b7cf6be233a65638c20a96ae299a755fc23589e14e491); /* line */ \n        c_0xc019abf3(0xd4afa738f7b35dfb69a1a9a54fa99a36326fd1f4075a6a4c077c965c3eda86b3); /* statement */ \nassert(\r\n            _msgSender() ==\r\n                _factory.getPair(\r\n                    IUniswapV2Pair(_msgSender()).token0(),\r\n                    IUniswapV2Pair(_msgSender()).token1()\r\n                )\r\n        ); // Ensure that _msgSender() is actually a V2 pair.\r\nc_0xc019abf3(0xb6bf857f7d9140b2ab59f1cb680fc22e6b36f928268bafc1eac545f7ac234ffa); /* line */ \n        c_0xc019abf3(0x4d150c71966cde8b7b9455dfba180a8601d938d549b4edaec64590b7d21c9e77); /* requirePre */ \nc_0xc019abf3(0xb3206382dc574cd1e6d8b42f7eed4177c317f06a0e204dcdf53511035cd6539b); /* statement */ \nrequire(sender == address(this), \"PrimitiveSwaps: NOT_SENDER\");c_0xc019abf3(0xc5839d25cb80a1592698310f84a0e249b7794c98901b2f1975a7278eadf5b26e); /* requirePost */ \n // Ensure called by this contract.\r\nc_0xc019abf3(0xc4f41264a7d4427b3e6bf18173ab9cffa4381623e1e7b799a2f7b39d849f51b3); /* line */ \n        c_0xc019abf3(0xc011be1a29496e19c69b2ac8c90129e56181ddf6326d80a6052737db6d99f567); /* statement */ \n(bool success, bytes memory returnData) = address(this).call(data); // Execute the callback.\r\nc_0xc019abf3(0x85e7df648d85f5b2da74c29fe9c0ba075b2e84bc431a1f0e4080e9bb0d90d47e); /* line */ \n        c_0xc019abf3(0xe8f7be3a78528124a5cf71a1c38e4ad8bdb42733143cc680fd624b9a3ce6e230); /* statement */ \n(uint256 amountA, uint256 amountB) = abi.decode(returnData, (uint256, uint256));\r\nc_0xc019abf3(0x59c27c8de258c065f10b0b0d5b289369069accec15ced74f9bd19d5303c60405); /* line */ \n        c_0xc019abf3(0x23d4b5f6d6576bf40666dc543357d0c7e2384920ab0a4f958e8737ad84db31ec); /* requirePre */ \nc_0xc019abf3(0x4f8d0d922ce4181272c5f7f6ecd730a8f63bdb366143df4954e5188eb2c4f480); /* statement */ \nrequire(\r\n            success && (returnData.length == 0 || amountA > 0 || amountB > 0),\r\n            \"PrimitiveSwaps: CALLBACK\"\r\n        );c_0xc019abf3(0xe01198f630747ae5c45d36ed16b46fe1048dd7b5f9c13427ebfcb048ed810207); /* requirePost */ \n\r\n    }\r\n\r\n    // ===== View =====\r\n\r\n    /**\r\n     * @notice  Gets the UniswapV2Router02 contract address.\r\n     */\r\n    function getRouter() public view override returns (IUniswapV2Router02) {c_0xc019abf3(0x2e38f35e2585ef53b5a4208170aa853653aa5be8bf7f2a2673ec95f3c0dec9d1); /* function */ \n\r\nc_0xc019abf3(0xbbac7fa8191303cb22291db1b20409b9a0519c0a526a75dfc7c7a38aa7235e20); /* line */ \n        c_0xc019abf3(0x1dc1221e3e0a90402c13f05b01c3e161597bc921122f480c1d2b56801809473b); /* statement */ \nreturn _router;\r\n    }\r\n\r\n    /**\r\n     * @notice  Gets the UniswapV2Factory contract address.\r\n     */\r\n    function getFactory() public view override returns (IUniswapV2Factory) {c_0xc019abf3(0xab8f353929bb579540032e06b3592c4b87b0d07a56b2374ae8bb47be9d4e22eb); /* function */ \n\r\nc_0xc019abf3(0xf48c0d6835bddb2af7430eb11c07f519d5fe025a788b3030f2b523e37393db6b); /* line */ \n        c_0xc019abf3(0x44d379b387126b5c1929376a7a0bc29ddb951a239ea1b8a2118fb66d09db8fd2); /* statement */ \nreturn _factory;\r\n    }\r\n\r\n    /**\r\n     * @notice  Fetchs the Uniswap Pair for an option's redeemToken and underlyingToken params.\r\n     * @param   option The option token to get the corresponding UniswapV2Pair market.\r\n     * @return  The pair address, as well as the tokens of the pair.\r\n     */\r\n    function getOptionPair(IOption option)\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            IUniswapV2Pair,\r\n            address,\r\n            address\r\n        )\r\n    {c_0xc019abf3(0x95554f53cc8139c284f096ddb354988a8f137864537145dd6dd10c78fcb3129f); /* function */ \n\r\nc_0xc019abf3(0x460a7460d02a61e1426fa8f5cec0df329849462feaf0f8d87a5b8f4d45fe692c); /* line */ \n        c_0xc019abf3(0xc8925695fdf46f4010cf137210511863bc79bf8ecd0c6a16b403c383c9671acc); /* statement */ \naddress redeem = option.redeemToken();\r\nc_0xc019abf3(0xba77b6d0ee65b26a3268d97892f0f3b9c5be0c196b7cd89a939ef57674c45e5a); /* line */ \n        c_0xc019abf3(0xbd058b17ee07295fac7c9a55fd98052a6af1090ca3e33c9e49f5d34752344460); /* statement */ \naddress underlying = option.getUnderlyingTokenAddress();\r\nc_0xc019abf3(0x4e68d6e6d8d7588271fbdf5ffdd643e2db9f526fa043d50bcb3024863968dca5); /* line */ \n        c_0xc019abf3(0x367a799c8798ed5e516875fc8e3457403b6ec16d9f7b3c5157be672edfa9d5f1); /* statement */ \nIUniswapV2Pair pair = IUniswapV2Pair(_factory.getPair(redeem, underlying));\r\nc_0xc019abf3(0x5f6ea313ac6dbe3b9fca2edcbdfee05c208b509a23d04521ca00a9e5e99ebf50); /* line */ \n        c_0xc019abf3(0xb6fbf7a9f856ebd2298d1dc0fc0cd37d4f11fcf1a9560e7b95c228fddeb0a4e5); /* statement */ \nreturn (pair, underlying, redeem);\r\n    }\r\n\r\n    /**\r\n     * @dev     Calculates the effective premium, denominated in underlyingTokens, to buy `quantity` of `optionToken`s.\r\n     * @notice  UniswapV2 adds a 0.3009027% fee which is applied to the premium as 0.301%.\r\n     *          IMPORTANT: If the pair's reserve ratio is incorrect, there could be a 'negative' premium.\r\n     *          Buying negative premium options will pay out redeemTokens.\r\n     *          An 'incorrect' ratio occurs when the (reserves of redeemTokens / strike ratio) >= reserves of underlyingTokens.\r\n     *          Implicitly uses the `optionToken`'s underlying and redeem tokens for the pair.\r\n     * @param   optionToken The optionToken to get the premium cost of purchasing.\r\n     * @param   quantity The quantity of long option tokens that will be purchased.\r\n     * @return  (uint, uint) Returns the `premium` to buy `quantity` of `optionToken` and the `negativePremium`.\r\n     */\r\n    function getOpenPremium(IOption optionToken, uint256 quantity)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256, uint256)\r\n    {c_0xc019abf3(0x46e042c2117343493a192515a85d00f203a0a4d0f30dd55d54ab50b58bd86675); /* function */ \n\r\nc_0xc019abf3(0x1d0749be412899075e24213f05d80c2ba689ed451ba6b38723d474c1a42e1c8b); /* line */ \n        c_0xc019abf3(0x4099dddc1eb6abec3761f1d2bd3d1defec4d91167ace4c1f757495111e643638); /* statement */ \nreturn SwapsLib.getOpenPremium(_router, optionToken, quantity);\r\n    }\r\n\r\n    /**\r\n     * @dev     Calculates the effective premium, denominated in underlyingTokens, to sell `optionToken`s.\r\n     * @param   optionToken The optionToken to get the premium cost of purchasing.\r\n     * @param   quantity The quantity of short option tokens that will be closed.\r\n     * @return  (uint, uint) Returns the `premium` to sell `quantity` of `optionToken` and the `negativePremium`.\r\n     */\r\n    function getClosePremium(IOption optionToken, uint256 quantity)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256, uint256)\r\n    {c_0xc019abf3(0x7793fe74f4cebb8de0332c45537381071d71476b8f3995abbe4a90396b1e7540); /* function */ \n\r\nc_0xc019abf3(0x745c6d1b4e65cf736fd3f370f516cd27cfdc50b4401d058748d7a10d81b99570); /* line */ \n        c_0xc019abf3(0xba6077de28bae827242e72402d28fce531ba990938c8c4836f5fa890d2de4aaf); /* statement */ \nreturn SwapsLib.getClosePremium(_router, optionToken, quantity);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/interfaces/IPrimitiveSwaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\nimport {\r\n    IUniswapV2Router02\r\n} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\r\nimport {\r\n    IUniswapV2Factory\r\n} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\r\nimport {IUniswapV2Pair} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\r\nimport {IOption} from \"@primitivefi/contracts/contracts/option/interfaces/IOption.sol\";\r\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\r\n\r\ninterface IPrimitiveSwaps {\r\n    // ==== External Functions ====\r\n\r\n    function openFlashLong(\r\n        IOption optionToken,\r\n        uint256 amountOptions,\r\n        uint256 maxPremium\r\n    ) external returns (bool);\r\n\r\n    function openFlashLongWithPermit(\r\n        IOption optionToken,\r\n        uint256 amountOptions,\r\n        uint256 maxPremium,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (bool);\r\n\r\n    function openFlashLongWithDAIPermit(\r\n        IOption optionToken,\r\n        uint256 amountOptions,\r\n        uint256 maxPremium,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (bool);\r\n\r\n    function openFlashLongWithETH(IOption optionToken, uint256 amountOptions)\r\n        external\r\n        payable\r\n        returns (bool);\r\n\r\n    function closeFlashLong(\r\n        IOption optionToken,\r\n        uint256 amountRedeems,\r\n        uint256 minPayout\r\n    ) external returns (bool);\r\n\r\n    function closeFlashLongForETH(\r\n        IOption optionToken,\r\n        uint256 amountRedeems,\r\n        uint256 minPayout\r\n    ) external returns (bool);\r\n\r\n    // ===== Callback =====\r\n\r\n    function uniswapV2Call(\r\n        address sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    // ==== View ====\r\n\r\n    function getRouter() external view returns (IUniswapV2Router02);\r\n\r\n    function getFactory() external view returns (IUniswapV2Factory);\r\n\r\n    function getOptionPair(IOption option)\r\n        external\r\n        view\r\n        returns (\r\n            IUniswapV2Pair,\r\n            address,\r\n            address\r\n        );\r\n\r\n    function getOpenPremium(IOption optionToken, uint256 quantity)\r\n        external\r\n        view\r\n        returns (uint256, uint256);\r\n\r\n    function getClosePremium(IOption optionToken, uint256 quantity)\r\n        external\r\n        view\r\n        returns (uint256, uint256);\r\n}\r\n"
    },
    "contracts/libraries/SwapsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Swaps Lib\r\n * @author  Primitive\r\n * @notice  Library for Swap Logic for Uniswap AMM.\r\n * @dev     @primitivefi/v1-connectors@2.0.0\r\n */\r\n\r\nimport {\r\n    IUniswapV2Router02\r\n} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\r\nimport {CoreLib, IOption, SafeMath} from \"./CoreLib.sol\";\r\n\r\nlibrary SwapsLib {\nfunction c_0x8b057fd9(bytes32 c__0x8b057fd9) public pure {}\n\r\n    using SafeMath for uint256; // Reverts on math underflows/overflows\r\n\r\n    /**\r\n     * @notice  Gets the amounts to pay out, pay back, and outstanding cost.\r\n     * @param   router The UniswapV2Router02 to use for calculating `amountsOut`.\r\n     * @param   optionToken The option token to use for fetching its corresponding Uniswap Pair.\r\n     * @param   redeemAmount The quantity of REDEEM tokens, with `quoteValue` units, needed to close the options.\r\n     */\r\n    function repayClose(\r\n        IUniswapV2Router02 router,\r\n        IOption optionToken,\r\n        uint256 redeemAmount\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {c_0x8b057fd9(0x94643f5f6cfad2ae3e31ead956d83b6c89b9a0adf145e15713ad8b954e0bd52f); /* function */ \n\r\n        // Outstanding is the cost remaining, should be 0 in most cases.\r\n        // Payout is the `premium` that the original caller receives in underlyingTokens.\r\nc_0x8b057fd9(0x99d1cde2599e91be25836a5fe5e2be01f5935f3f99413d88bfc37b9fbf6fb142); /* line */ \n        c_0x8b057fd9(0x5cdac69cee70190e7d963a97c7a374c58fb376a213a296663a878eb8e615f74b); /* statement */ \n(uint256 payout, uint256 outstanding) =\r\n            getClosePremium(router, optionToken, redeemAmount);\r\n\r\n        // In most cases there will be an underlying payout, which is subtracted from the redeemAmount.\r\nc_0x8b057fd9(0x7b36c435a9e306ac3a3c36493d90d421568ba08e87987c0c908e4f7bfde0d047); /* line */ \n        c_0x8b057fd9(0x8520b221974aefdd00bbdaed4985faf32750c9db548fe7d0a200e613fb5488e1); /* statement */ \nuint256 cost = CoreLib.getProportionalLongOptions(optionToken, redeemAmount);\r\nc_0x8b057fd9(0x10d6f2cb863269e9eddcf180e542df7706df127be453d41d03a58ba495ad957b); /* line */ \n        c_0x8b057fd9(0x1132bd361a481bef5770b80239bfbc4da3f83d4cf3348a37b2d998e6dfa32e61); /* statement */ \nif (payout > 0) {c_0x8b057fd9(0xf03081174c164f321f385075634ad0979faa3e36478a15f4e965ef1abedc7f87); /* branch */ \n\r\nc_0x8b057fd9(0x9fdc6967bd874419ea976ebc97fb10715c2e3545a28f940c496b4c97c0628387); /* line */ \n            c_0x8b057fd9(0x52c3aa9a3fc993147da69f87a1338e30fbbcf34252ea86d5dd537c4ee18f5030); /* statement */ \ncost = cost.sub(payout);\r\n        }else { c_0x8b057fd9(0x8bf755c5b28aafa3687c82cb546aa543a53aa4df5cfc612008c96cfdce0e5f2c); /* branch */ \n}\r\nc_0x8b057fd9(0x296365c223ff5136c9f339a6a3a79e825341e25c0cb9fdc1a37a89329db5ff27); /* line */ \n        c_0x8b057fd9(0xfb8890a5e9637331373f1b1450c2ce808f1683e12c0e55d6d580febd330ee9a8); /* statement */ \nreturn (payout, cost, outstanding);\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns the swap amounts required to return to repay the flash loan used to open a long position.\r\n     * @param   router The UniswapV2Router02 to use for calculating `amountsOut`.\r\n     * @param   optionToken The option token to use for fetching its corresponding Uniswap Pair.\r\n     * @param   underlyingAmount The quantity of UNDERLYING tokens, with `baseValue` units, needed to open the options.\r\n     */\r\n    function repayOpen(\r\n        IUniswapV2Router02 router,\r\n        IOption optionToken,\r\n        uint256 underlyingAmount\r\n    ) internal view returns (uint256, uint256) {c_0x8b057fd9(0x74e4163dc06f75c8e6dc9243728b31d70676338d675cfeeb08cf1d2dd480a784); /* function */ \n\r\n        // Premium is the `underlyingTokens` required to buy the `optionToken`.\r\n        // ExtraRedeems is the `redeemTokens` that are remaining.\r\n        // If `premium` is not 0, `extraRedeems` should be 0, else `extraRedeems` is the payout (a negative premium).\r\nc_0x8b057fd9(0xb68327ff9001a50a8d72934c8969ddcacd8d0dc0fa7ea5112299670dd3984d36); /* line */ \n        c_0x8b057fd9(0x0850a67f42ca1ccc14a9206539947b2e0c6ed235d0e7f35c7dd0b21c25798980); /* statement */ \n(uint256 premium, uint256 extraRedeems) =\r\n            getOpenPremium(router, optionToken, underlyingAmount);\r\n\r\nc_0x8b057fd9(0xa8cc6f7c8656f0b8a6092359d83ee5f8e98f4bf3ce016b23f5329421392e7f85); /* line */ \n        c_0x8b057fd9(0xf3ab260bd011a26b76fa496458ac64f551f0df11f2e69e4aae53ba788cd68064); /* statement */ \nuint256 redeemPremium =\r\n            CoreLib.getProportionalShortOptions(optionToken, underlyingAmount);\r\n\r\nc_0x8b057fd9(0x1be44908a9e9d6432bc0dcbb2753fd430bd3b1c8fcea910a85a0230ebb4f9d28); /* line */ \n        c_0x8b057fd9(0x30dfc0373349edda2f229dcaf138a61075e651aabdd33619ef1a0bb94a837979); /* statement */ \nif (extraRedeems > 0) {c_0x8b057fd9(0x755ee8f1c949724585eb685c2262c26f2807448cf3dc0981be6e166b17714683); /* branch */ \n\r\nc_0x8b057fd9(0x6a588a13a4716c609f3d818fd88f3b8676f5dccf07ce006b6b015bdda3d4fd00); /* line */ \n            c_0x8b057fd9(0x95e55cbd48cef41f2398456401e2c72b50751d9538366fc0b88c6313688e7ed8); /* statement */ \nredeemPremium = redeemPremium.sub(extraRedeems);\r\n        }else { c_0x8b057fd9(0x78b370910ee9180b66f3338fe8b426d13b2bd76b76e2517c89d15a1e44f3c9d1); /* branch */ \n}\r\nc_0x8b057fd9(0xa4be77188d6aafdad5cac3f7358f6accb388bedec3038aaa6ea971946c4fde67); /* line */ \n        c_0x8b057fd9(0x6ca405f8873b745937526c5ec069d6841a91f0e42ce66093fa6fcff317e31a45); /* statement */ \nreturn (premium, redeemPremium);\r\n    }\r\n\r\n    /**\r\n     * @dev    Calculates the effective premium, denominated in underlyingTokens, to buy `quantity` of `optionToken`s.\r\n     * @notice UniswapV2 adds a 0.3009027% fee which is applied to the premium as 0.301%.\r\n     *         IMPORTANT: If the pair's reserve ratio is incorrect, there could be a 'negative' premium.\r\n     *         Buying negative premium options will pay out redeemTokens.\r\n     *         An 'incorrect' ratio occurs when the (reserves of redeemTokens / strike ratio) >= reserves of underlyingTokens.\r\n     *         Implicitly uses the `optionToken`'s underlying and redeem tokens for the pair.\r\n     * @param  router The UniswapV2Router02 contract.\r\n     * @param  optionToken The optionToken to get the premium cost of purchasing.\r\n     * @param  quantity The quantity of long option tokens that will be purchased.\r\n     */\r\n    function getOpenPremium(\r\n        IUniswapV2Router02 router,\r\n        IOption optionToken,\r\n        uint256 quantity\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            /* override */\r\n            uint256,\r\n            uint256\r\n        )\r\n    {c_0x8b057fd9(0x49bb7c00d84efba9dc0d82feb5d24b50db26c35e3d0f6962350955a987480616); /* function */ \n\r\n        // longOptionTokens are opened by doing a swap from redeemTokens to underlyingTokens effectively.\r\nc_0x8b057fd9(0xc9e7faf70fd3a572066c6ad7d728bffac9d614485e72e3dcacb651613241a312); /* line */ \n        c_0x8b057fd9(0x5eb5fa45a0695a929bd9ab19048b3d9f9c00bf9293f6b458e59310d8a214bb0c); /* statement */ \naddress[] memory path = new address[](2);\r\nc_0x8b057fd9(0x0596eaff874697ff375421e986e7443968e12c4dd7f6206039932084615c0d35); /* line */ \n        c_0x8b057fd9(0x1b4f560fc80fd2e7c83008e5e5cb1cc1ee1f9a9c8bebc873dd95b4650ad3f817); /* statement */ \npath[0] = optionToken.redeemToken();\r\nc_0x8b057fd9(0x05a5af8cfa2dfde85852878fb04d57c526a46eb384263d8765efe6f418cbe070); /* line */ \n        c_0x8b057fd9(0x7a306110f4d5a34d29716895388aeb99c6a3f9021a7cc1ca83c6cae6bbf839b6); /* statement */ \npath[1] = optionToken.getUnderlyingTokenAddress();\r\n\r\n        // `quantity` of underlyingTokens are output from the swap.\r\n        // They are used to mint options, which will mint `quantity` * quoteValue / baseValue amount of redeemTokens.\r\nc_0x8b057fd9(0x8938d07a3e9188978febd0b34a0f0d38298e503d308bb0afdecc24b6e07cbf0c); /* line */ \n        c_0x8b057fd9(0xfe9ee170711e595e6b56039e6cacb110c9224fad4a88b0a77272d258ff3c07c7); /* statement */ \nuint256 redeemsMinted =\r\n            CoreLib.getProportionalShortOptions(optionToken, quantity);\r\n\r\n        // The loanRemainderInUnderlyings will be the amount of underlyingTokens that are needed from the original\r\n        // transaction caller in order to pay the flash swap.\r\n        // IMPORTANT: THIS IS EFFECTIVELY THE PREMIUM PAID IN UNDERLYINGTOKENS TO PURCHASE THE OPTIONTOKEN.\r\nc_0x8b057fd9(0xeeb859397032fce4d4f13a0efb4ca67b6e664f56af259e6fb14d8cce8d14f9fb); /* line */ \n        c_0x8b057fd9(0x60d2f61830313086e39233567d5a16b74f615a7d5fdf8187a439a92aea5f6a0b); /* statement */ \nuint256 loanRemainderInUnderlyings;\r\n\r\n        // Economically, negativePremiumPaymentInRedeems value should always be 0.\r\n        // In the case that we minted more redeemTokens than are needed to pay back the flash swap,\r\n        // (short -> underlying is a positive trade), there is an effective negative premium.\r\n        // In that case, this function will send out `negativePremiumAmount` of redeemTokens to the original caller.\r\n        // This means the user gets to keep the extra redeemTokens for free.\r\n        // Negative premium amount is the opposite difference of the loan remainder: (paid - flash loan amount)\r\nc_0x8b057fd9(0xa3a3d76a031f89a30a939610d3a02fce0d679140d0ebadcadb33d0095ad3b027); /* line */ \n        c_0x8b057fd9(0x0a8c64239d02a14480aecaf14d188bde10467eaf9886e3aa9b0095634e46f689); /* statement */ \nuint256 negativePremiumPaymentInRedeems;\r\n\r\n        // Since the borrowed amount is underlyingTokens, and we are paying back in redeemTokens,\r\n        // we need to see how much redeemTokens must be returned for the borrowed amount.\r\n        // We can find that value by doing the normal swap math, getAmountsIn will give us the amount\r\n        // of redeemTokens are needed for the output amount of the flash loan.\r\n        // IMPORTANT: amountsIn[0] is how many short tokens we need to pay back.\r\n        // This value is most likely greater than the amount of redeemTokens minted.\r\nc_0x8b057fd9(0x5489139fbb2b51db4a981a0ffbc9fab29561ea5513c1fa82cff304a9d2b9bb07); /* line */ \n        c_0x8b057fd9(0x8c6dedc1610574214be03440a45ffb975d0b6b652c2bc3e43bdf398de5a3098d); /* statement */ \nuint256[] memory amountsIn = router.getAmountsIn(quantity, path);\r\nc_0x8b057fd9(0x1b349352c000e08f485a6bfcc56494ae85dd1e011c2a0b395fca19be5277bf18); /* line */ \n        c_0x8b057fd9(0x11209cccb7c66893b9176021bb0d271cf07fd314c2717e66e0f9ea098c6357fd); /* statement */ \nuint256 redeemsRequired = amountsIn[0]; // the amountIn of redeemTokens based on the amountOut of `quantity`.\r\n        // If redeemsMinted is greater than redeems required, there is a cost of 0, implying a negative premium.\r\nc_0x8b057fd9(0x270dbb6cdfce85de65a3105774c854f1bba31f6b994cef5cdf88e4c8ff50f7de); /* line */ \n        c_0x8b057fd9(0x787c3971ddb4d660c0268dd1d1323ccea66b28a5bf30d66556210aeb7629ac25); /* statement */ \nuint256 redeemCostRemaining =\r\n            redeemsRequired > redeemsMinted ? redeemsRequired.sub(redeemsMinted) : 0;\r\n        // If there is a negative premium, calculate the quantity of remaining redeemTokens after the `redeemsMinted` is spent.\r\nc_0x8b057fd9(0x7aadbe950ac1b33789faae73fcbb4ebdd644ff8c3833bc25dd4953bcb13c3b08); /* line */ \n        c_0x8b057fd9(0xd8274230338dc562cfb1b0d026d2f90b741f1a998cdbe861f0c279d1a09f2598); /* statement */ \nnegativePremiumPaymentInRedeems = redeemsMinted > redeemsRequired\r\n            ? redeemsMinted.sub(redeemsRequired)\r\n            : 0;\r\n\r\n        // In most cases, there will be an outstanding cost (assuming we minted less redeemTokens than the\r\n        // required amountIn of redeemTokens for the swap).\r\nc_0x8b057fd9(0x724182d6ed9445db294629d2ba5bd0a9a3f37c9c0417469f56a0021659290929); /* line */ \n        c_0x8b057fd9(0xbb37c2c96b5ae8d25f1a5154db79800f5cf81de7838b8dc9843b81eff3c2369a); /* statement */ \nif (redeemCostRemaining > 0) {c_0x8b057fd9(0x97e4cf49b6bd03eb13aeb066af4e0cce5926f36aaf7cddf9c3211e1408063e7e); /* branch */ \n\r\n            // The user won't want to pay back the remaining cost in redeemTokens,\r\n            // because they borrowed underlyingTokens to mint them in the first place.\r\n            // So instead, we get the quantity of underlyingTokens that could be paid instead.\r\n            // We can calculate this using normal swap math.\r\n            // getAmountsOut will return the quantity of underlyingTokens that are output,\r\n            // based on some input of redeemTokens.\r\n            // The input redeemTokens is the remaining redeemToken cost, and the output\r\n            // underlyingTokens is the proportional amount of underlyingTokens.\r\n            // amountsOut[1] is then the outstanding flash loan value denominated in underlyingTokens.\r\nc_0x8b057fd9(0x950da0d599a39c068c40e2020927f00fcc77971549e4adf72d5d90e542a27c78); /* line */ \n            c_0x8b057fd9(0x340d8c8193f7afa0230b44a4069991a5c7703d8c945e46d9aadd40e1127d8236); /* statement */ \nuint256[] memory amountsOut = router.getAmountsOut(redeemCostRemaining, path);\r\n\r\n            // Returning withdrawn tokens to the pair has a fee of .003 / .997 = 0.3009027% which must be applied.\r\nc_0x8b057fd9(0x4ae7a328ae15325574278ed26ecce709d4317ca1be344dcb3bac7e56592f0db6); /* line */ \n            c_0x8b057fd9(0xc8c5a38e620f973fcb8e01462e44bded52257bdf9382b0159ccebaef6997cac0); /* statement */ \nloanRemainderInUnderlyings = (\r\n                amountsOut[1].mul(100000).add(amountsOut[1].mul(301))\r\n            )\r\n                .div(100000);\r\n        }else { c_0x8b057fd9(0xd406b57aeb2c55632f2a85d1af8e6127887efe24e35b13afd8c659ae2b2f3e87); /* branch */ \n}\r\nc_0x8b057fd9(0xd721926cf1af930ce08367e81d042f680d0145bb761025b24232c8079940c752); /* line */ \n        c_0x8b057fd9(0x5bb2b92d795843f0770c9e346065f1c83593470534347e34f2d0cd934d8c3370); /* statement */ \nreturn (loanRemainderInUnderlyings, negativePremiumPaymentInRedeems);\r\n    }\r\n\r\n    /**\r\n     * @dev    Calculates the effective premium, denominated in underlyingTokens, to sell `optionToken`s.\r\n     * @param  router The UniswapV2Router02 contract.\r\n     * @param  optionToken The optionToken to get the premium cost of purchasing.\r\n     * @param  quantity The quantity of short option tokens that will be closed.\r\n     */\r\n    function getClosePremium(\r\n        IUniswapV2Router02 router,\r\n        IOption optionToken,\r\n        uint256 quantity\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            /* override */\r\n            uint256,\r\n            uint256\r\n        )\r\n    {c_0x8b057fd9(0xe86bc13dc7a3c9ba610d7f5780846af8f625aa80d0f0cbd27fe131cdeebc5178); /* function */ \n\r\n        // longOptionTokens are closed by doing a swap from underlyingTokens to redeemTokens.\r\nc_0x8b057fd9(0x0265a404a1cf6c3f85a9fbcbdd174755cb89926af05549e110e7c2e888c6ad9a); /* line */ \n        c_0x8b057fd9(0xe02bfa70f22912efd99c2ac19e7476bdf811b8f6f36bcf2f3c2debd1d8ecc670); /* statement */ \naddress[] memory path = new address[](2);\r\nc_0x8b057fd9(0xe111dee85bf1456f9308d2089651931b22c282dab68bba5319980563f9d36ce2); /* line */ \n        c_0x8b057fd9(0xfa9bdfb281758da79d82996fbb4b5a726e5121f117f8e4c78ebe4b70e3ccd532); /* statement */ \npath[0] = optionToken.getUnderlyingTokenAddress();\r\nc_0x8b057fd9(0xdbd376464e5ac9dc6fe79dbb6344dd90d2670e37f220ad33ff7627303c62f1fb); /* line */ \n        c_0x8b057fd9(0xdecb4ac5cb4be14f8c13264667d1422d86290d7ba86060ff85666fd662c3b4b3); /* statement */ \npath[1] = optionToken.redeemToken();\r\nc_0x8b057fd9(0x75b97c383f419fc812fd454531ee899b7d1fa07e4288589e1f087a0e99ec3365); /* line */ \n        c_0x8b057fd9(0x097e93679d4c43f86ee104202a16a41e318825bbe4435db1746522d3473e9132); /* statement */ \nuint256 outputUnderlyings =\r\n            CoreLib.getProportionalLongOptions(optionToken, quantity);\r\n        // The loanRemainder will be the amount of underlyingTokens that are needed from the original\r\n        // transaction caller in order to pay the flash swap.\r\nc_0x8b057fd9(0x681f73037d3db08e537407d871cd64cd6cadfe583f27ed0dfccdc53ba69c722c); /* line */ \n        c_0x8b057fd9(0x6fdd48b37f20a881e80f528be40537ce7bf4e6daf0e7129c69948d2a3d0ada42); /* statement */ \nuint256 loanRemainder;\r\n\r\n        // Economically, underlyingPayout value should always be greater than 0, or this trade shouldn't be made.\r\n        // If an underlyingPayout is greater than 0, it means that the redeemTokens borrowed are worth less than the\r\n        // underlyingTokens received from closing the redeemToken<>optionTokens.\r\n        // If the redeemTokens are worth more than the underlyingTokens they are entitled to,\r\n        // then closing the redeemTokens will cost additional underlyingTokens. In this case,\r\n        // the transaction should be reverted. Or else, the user is paying extra at the expense of\r\n        // rebalancing the pool.\r\nc_0x8b057fd9(0xecd1732486c2debfcf455afdc5619c2eefc76502ab95540968eb9848982bcf8d); /* line */ \n        c_0x8b057fd9(0x6265f22f30490f6062560c11ba2b9d2cc9628d4a499bb5c38d8c721744f02d1e); /* statement */ \nuint256 underlyingPayout;\r\n\r\n        // Since the borrowed amount is redeemTokens, and we are paying back in underlyingTokens,\r\n        // we need to see how much underlyingTokens must be returned for the borrowed amount.\r\n        // We can find that value by doing the normal swap math, getAmountsIn will give us the amount\r\n        // of underlyingTokens are needed for the output amount of the flash loan.\r\n        // IMPORTANT: amountsIn 0 is how many underlyingTokens we need to pay back.\r\n        // This value is most likely greater than the amount of underlyingTokens received from closing.\r\nc_0x8b057fd9(0xf01c7b8edf3349db53a320b53e6b65e8631dd95772744a80fd4272847534d9c0); /* line */ \n        c_0x8b057fd9(0x97086f2a559d27e8756d608426c8e3ce660c86e9cfc68d75e5cbb3a363cd98a9); /* statement */ \nuint256[] memory amountsIn = router.getAmountsIn(quantity, path);\r\n\r\nc_0x8b057fd9(0xd35b0c4ae6dca21a9ee6a01864a5f529a9e5049b4f73be039b80391037dc6800); /* line */ \n        c_0x8b057fd9(0x5b7046b1379888bc18e221d664fcf738475d0ec6ffcecc7164b72550fc130b0b); /* statement */ \nuint256 underlyingsRequired = amountsIn[0]; // the amountIn required of underlyingTokens based on the amountOut of flashloanQuantity\r\n        // If outputUnderlyings (received from closing) is greater than underlyings required,\r\n        // there is a positive payout.\r\nc_0x8b057fd9(0x939eb7fdcb94308b13bd4e7dd0167e4b4e6c86f7d38454ba4c1df3079263c4dd); /* line */ \n        c_0x8b057fd9(0xd3864f2d1cfd3a4d8f06300afb766358bbe7926abbcac9977acd33e8282bc10f); /* statement */ \nunderlyingPayout = outputUnderlyings > underlyingsRequired\r\n            ? outputUnderlyings.sub(underlyingsRequired)\r\n            : 0;\r\n\r\n        // If there is a negative payout, calculate the remaining cost of underlyingTokens.\r\nc_0x8b057fd9(0x27f6e766021bc80fdb46ade2a32329306e09bd7c10ed5fb2bd2a6ea9d2837d9c); /* line */ \n        c_0x8b057fd9(0xb0efde4fa85ee02260d03a8eddff0d17ccf1e476b7736bbdef4834b0419c8871); /* statement */ \nuint256 underlyingCostRemaining =\r\n            underlyingsRequired > outputUnderlyings\r\n                ? underlyingsRequired.sub(outputUnderlyings)\r\n                : 0;\r\n\r\n        // In the case that there is a negative payout (additional underlyingTokens are required),\r\n        // get the remaining cost into the `loanRemainder` variable and also check to see\r\n        // if a user is willing to pay the negative cost. There is no rational economic incentive for this.\r\nc_0x8b057fd9(0x5aef820246d7785c06b7ba6320cd73676e7a3f84e09973ed005e7c5dd1dcd032); /* line */ \n        c_0x8b057fd9(0xed4b0cd868144fc155684c16c33beeafbc2fdc3be30ee4e0ba553c70df1aef06); /* statement */ \nif (underlyingCostRemaining > 0) {c_0x8b057fd9(0x897f94709a4d56e8f6d39f09c13f4c47e256fba4e6277a31d462350c3fdb9262); /* branch */ \n\r\nc_0x8b057fd9(0x46d7876bb7f4fb1257b949c86a7f3d5b857dc64e4d50d9187599c7a6de11694d); /* line */ \n            c_0x8b057fd9(0x991249ec1b76ff50ce71024b283555a4c2cde348c919a0c386a13ffb35ab2c74); /* statement */ \nloanRemainder = underlyingCostRemaining;\r\n        }else { c_0x8b057fd9(0x0b7e131c74720a0f65fbb91a517eabbef90b8c7b415a8a945434646afb220ad1); /* branch */ \n}\r\nc_0x8b057fd9(0xdda418ab36209de26e2cd738b1e9c253cdd39a7e2eb4172ec4857e321ef04f21); /* line */ \n        c_0x8b057fd9(0x1d9e69ba7b4b1c59baaaf63952a6a3c576c6c3f48824bc03008619752a319ff3); /* statement */ \nreturn (underlyingPayout, loanRemainder);\r\n    }\r\n}\r\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/interfaces/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC20Permit {\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/connectors/PrimitiveLiquidity.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Liquidity\r\n * @author  Primitive\r\n * @notice  Manage liquidity on Uniswap & Sushiswap Venues.\r\n * @dev     @primitivefi/v1-connectors@v2.0.0\r\n */\r\n\r\n// Open Zeppelin\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n// Interfaces\r\nimport {\r\n    IPrimitiveLiquidity,\r\n    IUniswapV2Router02,\r\n    IUniswapV2Factory,\r\n    IUniswapV2Pair,\r\n    IERC20Permit,\r\n    IOption\r\n} from \"../interfaces/IPrimitiveLiquidity.sol\";\r\n// Primitive\r\nimport {PrimitiveConnector} from \"./PrimitiveConnector.sol\";\r\nimport {CoreLib, SafeMath} from \"../libraries/CoreLib.sol\";\r\n\r\ninterface DaiPermit {\r\n    function permit(\r\n        address holder,\r\n        address spender,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        bool allowed,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\ncontract PrimitiveLiquidity is PrimitiveConnector, IPrimitiveLiquidity, ReentrancyGuard {\nfunction c_0x4a07720e(bytes32 c__0x4a07720e) public pure {}\n\r\n    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\r\n    using SafeMath for uint256; // Reverts on math underflows/overflows\r\n\r\n    event Initialized(address indexed from); // Emitted on deployment.\r\n    event AddLiquidity(address indexed from, address indexed option, uint256 liquidity);\r\n    event RemoveLiquidity(\r\n        address indexed from,\r\n        address indexed option,\r\n        uint256 totalUnderlying\r\n    );\r\n\r\n    IUniswapV2Factory private _factory; // The Uniswap V2 factory contract to get pair addresses from.\r\n    IUniswapV2Router02 private _router; // The Uniswap Router contract used to interact with the protocol.\r\n\r\n    // ===== Constructor =====\r\n    constructor(\r\n        address weth_,\r\n        address primitiveRouter_,\r\n        address factory_,\r\n        address router_\r\n    ) public PrimitiveConnector(weth_, primitiveRouter_) {c_0x4a07720e(0xbb0fe83038a06d6c7f60a829a6c057172afc25315489f3dad17ceb4676652318); /* function */ \n\r\nc_0x4a07720e(0x15c0411771a4e8c6e81e9142ee80778df1813e1a4a1f06cf8fbe60466e3a38c7); /* line */ \n        c_0x4a07720e(0x4375fd86d4fde9affefe20c941c034b0c1f27719744dd6f2833b67b00def44a5); /* statement */ \n_factory = IUniswapV2Factory(factory_);\r\nc_0x4a07720e(0x208074defd7db1e5f3ece638653767f5fc293464a642fb1359ed8dcc5f4be9a8); /* line */ \n        c_0x4a07720e(0x6a6756509de6be82fe66a898225f7c1f24b7916139fdfb03a910a53438ee9f8d); /* statement */ \n_router = IUniswapV2Router02(router_);\r\nc_0x4a07720e(0x97506ab0eb950ae32acc303d5915711cb2e49d2f04534df80cfbf3fccfece6d9); /* line */ \n        c_0x4a07720e(0x064d69d1d562031b6a7cf06a3f23922072773f2ba868c38bfa7ca1223f26fb9b); /* statement */ \nemit Initialized(_msgSender());\r\n    }\r\n\r\n    // ===== Liquidity Operations =====\r\n\r\n    /**\r\n     * @dev     Adds redeemToken liquidity to a redeem<>underlyingToken pair by minting redeemTokens with underlyingTokens.\r\n     * @notice  Pulls underlying tokens from _msgSender() and pushes UNI-V2 liquidity tokens to the \"getCaller()\" address.\r\n     *          underlyingToken -> redeemToken -> UNI-V2.\r\n     * @param   optionAddress The address of the optionToken to get the redeemToken to mint then provide liquidity for.\r\n     * @param   quantityOptions The quantity of underlyingTokens to use to mint option + redeem tokens.\r\n     * @param   amountBMax The quantity of underlyingTokens to add with redeemTokens to the Uniswap V2 Pair.\r\n     * @param   amountBMin The minimum quantity of underlyingTokens expected to provide liquidity with.\r\n     * @param   to The address that receives UNI-V2 shares.\r\n     * @param   deadline The timestamp to expire a pending transaction.\r\n     */\r\n    function addShortLiquidityWithUnderlying(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        public\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(IOption(optionAddress))\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {c_0x4a07720e(0xedd0ec42ce74ffcebe02eda4fb21649408a86317d8d9cd024356a485579e3756); /* function */ \n\r\nc_0x4a07720e(0x758236d7b9fee45581ee561af3479e0d4f0ff314594b4614291e52514755ebec); /* line */ \n        c_0x4a07720e(0x68cae0b05b893226a5dfd12154df7b0d71785e770ca90b8273f5adfe323fa2dc); /* statement */ \nuint256 amountA;\r\nc_0x4a07720e(0xef0b67f9e720c276bfeb4d8676d5649ef7acd8f91341b1d20267abda531b0109); /* line */ \n        c_0x4a07720e(0xc950dc37cc1ab4bd7152b17474fec3787d15533fe9b2d1f943a6a14e58ba36bd); /* statement */ \nuint256 amountB;\r\nc_0x4a07720e(0x257b110aea0664aca813a77034cbe71e68825d4d61a6b896b5a7a481161511c9); /* line */ \n        c_0x4a07720e(0xd19af10e414b5910899478db58cc01c8d3e91bb41a0e64aaf8977229e602fb74); /* statement */ \nuint256 liquidity;\r\nc_0x4a07720e(0x83fa684b5f4201b8fd804a97e7543a22855c8c6324be4aa601152ed2edcb9f3e); /* line */ \n        c_0x4a07720e(0x1641fa9985c115001ffc2d0427c569702b113e6b33e1b11465764c9f9904fe28); /* statement */ \naddress underlying = IOption(optionAddress).getUnderlyingTokenAddress();\r\n        // Pulls total = (quantityOptions + amountBMax) of underlyingTokens from `getCaller()` to this contract.\r\nc_0x4a07720e(0x38c096d69609934b2fbd55a37bf6b6815d8c54728a4f77262b502e13eb960b05); /* line */ \n        {\r\nc_0x4a07720e(0x05032d931b0fcc5c68f7dda9afa8fe2e0426e1b649f1643c1bbc21df7597c9fc); /* line */ \n            c_0x4a07720e(0xbe018d65c1506ef07d970eba41aca56f8a0caafaeecaff7e968d0ac4eca83052); /* statement */ \nuint256 sum = quantityOptions.add(amountBMax);\r\nc_0x4a07720e(0x2606dfe4f8ec5e5a59d1ec33a473a57c23ed55149f2578f5882c88bd49521fb8); /* line */ \n            c_0x4a07720e(0x3f14ef4eb5ef187856d980f3a8bc3aac2bf996961f980631670629fb58852684); /* statement */ \n_transferFromCaller(underlying, sum);\r\n        }\r\n        // Pushes underlyingTokens to option contract and mints option + redeem tokens to this contract.\r\nc_0x4a07720e(0x67a3deffee90bc11be22848d43ef875f2422c08a03945afcbf58a76f8369480d); /* line */ \n        c_0x4a07720e(0x37db1db8b24ee2bfca2e60df45aaa185bb9f5aabd9d94ea4f31965f338bb2abe); /* statement */ \nIERC20(underlying).safeTransfer(optionAddress, quantityOptions);\r\nc_0x4a07720e(0x2caafc627aea7c2ebfa9c4a131e43f00677b34ba1bea88cd097b0b560cfb40a5); /* line */ \n        c_0x4a07720e(0xae1cbcde95265719aca818a164b76e2115d0c20a32ba50c984b6cd766fe5bab2); /* statement */ \n(, uint256 outputRedeems) = IOption(optionAddress).mintOptions(address(this));\r\n\r\nc_0x4a07720e(0x2681c6b9ae99db3a11fc8ed07a0492c8874a611df9ff47b4f729562b7177f641); /* line */ \n        {\r\n            // scope for adding exact liquidity, avoids stack too deep errors\r\nc_0x4a07720e(0x52298f751acf5ffafacc0a6ca7d487a6c91b6c4fe6fbb7faa1491c795cbbde4c); /* line */ \n            c_0x4a07720e(0x578e0559e7e0f0dcae9ab05deb60deab1447b8d153151d82400dc5a6ecb24ae5); /* statement */ \nIOption optionToken = IOption(optionAddress);\r\nc_0x4a07720e(0x21bc5e14d0ab0c2a9f2c9cea92d740db72fc11282760b2eb47592ad6d36fbac5); /* line */ \n            c_0x4a07720e(0x911dac7fb976090a35855a2b8fe4fae7b530a24812108f3a65686be859da34a6); /* statement */ \naddress redeem = optionToken.redeemToken();\r\nc_0x4a07720e(0x233736371a434a315f3fbb91756b92b0e99ff69be54352adeba6e19f0317ec99); /* line */ \n            c_0x4a07720e(0x4bb7fdc1a30263f7f483edb8b90e8902abd6b4a570da8bcc2d0b859ae34eac45); /* statement */ \nAddAmounts memory params;\r\nc_0x4a07720e(0xcaf0d9caab217bf897f1f942d9afd32a9c3345bc8af6cc003ef1b1deeaf1887c); /* line */ \n            c_0x4a07720e(0x55201a1bd91bd8027f7331972e246de91add9260c05fdb9b247d13538caf102b); /* statement */ \nparams.amountAMax = outputRedeems;\r\nc_0x4a07720e(0xcbe1939bd9beb5fd8a417c77b2e39e133f9662c2418c12c4b322b0dce93a0dab); /* line */ \n            c_0x4a07720e(0xadd163ed1d22cfa148b8f0b30f2d01dfd6798456e0a71792b3cfd90d7809a308); /* statement */ \nparams.amountBMax = amountBMax;\r\nc_0x4a07720e(0xeab80f4d2e877d2242bb230ed03e125d9122316689e210a7a0cd245375914689); /* line */ \n            c_0x4a07720e(0x8928798ad0f3d216d29c7ea6d6cd702fbe899cfbda0ed41cba51dfc3e79b46a0); /* statement */ \nparams.amountAMin = outputRedeems;\r\nc_0x4a07720e(0x2b04a2e61fa170d589eac3b66e5dc7386dfe6349551708ab641bf91c667bc8d1); /* line */ \n            c_0x4a07720e(0x498dd57fd9e051b855296efa5c48ff56cec7fbadc7467d7f911eebb53e5018bd); /* statement */ \nparams.amountBMin = amountBMin;\r\nc_0x4a07720e(0xa7997f54c731d1832791c68686e1e93d7ec0dabc8351bfec3370cad113651ac6); /* line */ \n            c_0x4a07720e(0x454d06567c7fdd7e90cdd93db6475ad9d5ec32320841d8b631b8d4c1502d8ea6); /* statement */ \nparams.deadline = deadline;\r\n            // Approves Uniswap V2 Pair pull tokens from this contract.\r\nc_0x4a07720e(0x672641ea2202f22faabf7867c26ae4637d296b5f978bcf673b1a927a4edd32cd); /* line */ \n            c_0x4a07720e(0xde595470b7e7ee75519ae28139b2529aa2f9051e2800eb84e3330f19fe901209); /* statement */ \ncheckApproval(redeem, address(_router));\r\nc_0x4a07720e(0x413231f57852a09c1abaf1ee1f00bc219ffd22c744df292487f38f9260518bad); /* line */ \n            c_0x4a07720e(0x9e718d8603a5b051a51993b433e435d066950c35a85f71567cd756c8d7cb5175); /* statement */ \ncheckApproval(underlying, address(_router));\r\n            // Adds liquidity to Uniswap V2 Pair and returns liquidity shares to the \"getCaller()\" address.\r\nc_0x4a07720e(0xaf09643cf33d1985d22f14dea23a630bc3ac743f2b5be2906f7a042cd694b9be); /* line */ \n            c_0x4a07720e(0x493fe1b1596137ab797101f29225b8839aede6253dea05104081c979e8986128); /* statement */ \n(amountA, amountB, liquidity) = _addLiquidity(redeem, underlying, params);\r\n            // Check for exact liquidity provided.\r\nc_0x4a07720e(0x0c5a69ee0c7a33c8bff912e0eaa4b7ab12df60f6307cba9ae37ac808b6ee03de); /* line */ \n            c_0x4a07720e(0x463853bbabf40d99f51542e06a5d53bf03976492f9893a12dbcbd07e78251e80); /* statement */ \nassert(amountA == outputRedeems);\r\n            // Return remaining tokens\r\nc_0x4a07720e(0xe123666a2f7e7551a5ed6e8c8ac96ea743062b77e96bb7cdb84d3a4316cc4935); /* line */ \n            c_0x4a07720e(0x9508b6faded11c04b48e0b4a53351bdb2e6434dbf393c7c739a6a45e0ad96ca0); /* statement */ \n_transferToCaller(underlying);\r\nc_0x4a07720e(0x8a7649d239a6b84e99e410ba94a9131799e2ce572494ee5b39029d3f196f7173); /* line */ \n            c_0x4a07720e(0xd45d3ce84c7ef09f60c3deb395a466ef00025b0b28713670b15b668602212d8b); /* statement */ \n_transferToCaller(redeem);\r\nc_0x4a07720e(0x0494ccf0b9c04697d491fca1ca2a07ec63a728e1f97c59ca7debd2c7be2990a5); /* line */ \n            c_0x4a07720e(0xe421b3bed3f4744044d84d3a1d318535c05821a5fcd66e805ec093d8cea62afd); /* statement */ \n_transferToCaller(address(optionToken));\r\n        }\r\nc_0x4a07720e(0xe5141e7de8ca4cb12c67399f9caf303394189a58728efdab003903e4211d20c5); /* line */ \n        c_0x4a07720e(0xf6d7819c3554b68f4ba683802b10fdea81fdf6cb1c831a25afe0c9b53c371ae8); /* statement */ \nemit AddLiquidity(getCaller(), optionAddress, liquidity);\r\nc_0x4a07720e(0x64fcc965574334dfcbcc2152bd0fffc6c75bb42f0d807690f1e7ef14e30a5eb8); /* line */ \n        c_0x4a07720e(0x27e0327b2bb780692c0da59a04236d8231e48b0e78af7548cfd4fc1bc6a2a070); /* statement */ \nreturn (amountA, amountB, liquidity);\r\n    }\r\n\r\n    /**\r\n     * @dev     Adds redeemToken liquidity to a redeem<>underlyingToken pair by minting shortOptionTokens with underlyingTokens.\r\n     * @notice  Pulls underlying tokens from _msgSender() and pushes UNI-V2 liquidity tokens to the \"getCaller()\" address.\r\n     *          underlyingToken -> redeemToken -> UNI-V2. Uses permit so user does not need to `approve()` our contracts.\r\n     * @param   optionAddress The address of the optionToken to get the redeemToken to mint then provide liquidity for.\r\n     * @param   quantityOptions The quantity of underlyingTokens to use to mint option + redeem tokens.\r\n     * @param   amountBMax The quantity of underlyingTokens to add with shortOptionTokens to the Uniswap V2 Pair.\r\n     * @param   amountBMin The minimum quantity of underlyingTokens expected to provide liquidity with.\r\n     * @param   to The address that receives UNI-V2 shares.\r\n     * @param   deadline The timestamp to expire a pending transaction.\r\n     */\r\n    function addShortLiquidityWithUnderlyingWithPermit(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n        override\r\n        onlyRegistered(IOption(optionAddress))\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {c_0x4a07720e(0x245253ce4ed7631eeb749875a23c46be83ec9e8728d0a93488ad2c17e01ccd6f); /* function */ \n\r\nc_0x4a07720e(0xcae3ff1e48a97ad8e1f3ce7da5391035a128e013655977b7cb8a760cec4c64c4); /* line */ \n        {\r\n            // avoids stack too deep errors\r\nc_0x4a07720e(0x4147377a6cb682c8cf7b00bf2036170e50f9403345db6ec944648466f123d7e5); /* line */ \n            c_0x4a07720e(0x530188d709202126b800298500f41f5f38af9dad6db9ded5484e8a13ae224b8e); /* statement */ \naddress underlying = IOption(optionAddress).getUnderlyingTokenAddress();\r\nc_0x4a07720e(0xc8067fd3a88f46dca596ca19209f832e62fc3a201bef40d59d4e13382c2f0306); /* line */ \n            c_0x4a07720e(0x80765cee36ccf6454b44f675c89835bbc6ecf264ad05329095cd123ac18275f8); /* statement */ \nuint256 sum = quantityOptions.add(amountBMax);\r\nc_0x4a07720e(0xa0380e9542e47fa057ea8eb96ef7935f7cc67eac56f04ddd5374b555d2dd7296); /* line */ \n            c_0x4a07720e(0x24eb272b62a15b720a2a7b2b76d2145b80ef079e150b63ac8bc110e7f4fe8df9); /* statement */ \nIERC20Permit(underlying).permit(\r\n                getCaller(),\r\n                address(_primitiveRouter),\r\n                sum,\r\n                deadline,\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n        }\r\nc_0x4a07720e(0x83170348261fe188a921e6a74fe2c2a02524f745e5628f7e9d3bcd3f7ceb5694); /* line */ \n        c_0x4a07720e(0x870d07a6bd4c7a59fd96b199912b52d4e990c7d0ee15aaf4228f0239df563f1e); /* statement */ \nreturn\r\n            addShortLiquidityWithUnderlying(\r\n                optionAddress,\r\n                quantityOptions,\r\n                amountBMax,\r\n                amountBMin,\r\n                to,\r\n                deadline\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice  Specialized function for `permit` calling on Put options (DAI).\r\n     */\r\n    function addShortLiquidityDAIWithPermit(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n        override\r\n        onlyRegistered(IOption(optionAddress))\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {c_0x4a07720e(0x00e406d1496d2ce4e349cc2e077de6d5dc23c360a464b0f9339383e301393f66); /* function */ \n\r\nc_0x4a07720e(0xa821d9b8b44836769e98892dec66e72e02c34fb4ddc6648b96e9b9f7ab39b078); /* line */ \n        c_0x4a07720e(0x37726197f62f716be54d13a7550aacbceabc8b4bd7751bc05a34adc7472156c2); /* statement */ \naddress underlying = IOption(optionAddress).getUnderlyingTokenAddress();\r\nc_0x4a07720e(0x76d639b68fbf677d538cfbd610c93163666543a4396eee2a9a95f17102ed8d23); /* line */ \n        c_0x4a07720e(0x9813c23c52043f5a060c4124a3085a0736ecf792037249305e2e5d99832cfc3f); /* statement */ \nDaiPermit(underlying).permit(\r\n            getCaller(),\r\n            address(_primitiveRouter),\r\n            IERC20Permit(underlying).nonces(getCaller()),\r\n            deadline,\r\n            true,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\nc_0x4a07720e(0x1f1126639c59467dcb0cc715aa156be17f3cfb751d4fa5173e47cc5eba59f0fa); /* line */ \n        c_0x4a07720e(0x21d61646b202def5a7eccc0505f158353ef931dda76c68d4035f9adb3b702ae1); /* statement */ \nreturn\r\n            addShortLiquidityWithUnderlying(\r\n                optionAddress,\r\n                quantityOptions,\r\n                amountBMax,\r\n                amountBMin,\r\n                to,\r\n                deadline\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev     Adds redeemToken liquidity to a redeem<>underlyingToken pair by minting shortOptionTokens with underlyingTokens.\r\n     * @notice  Pulls underlying tokens from _msgSender() and pushes UNI-V2 liquidity tokens to the \"getCaller()\" address.\r\n     *          underlyingToken -> redeemToken -> UNI-V2.\r\n     * @param   optionAddress The address of the optionToken to get the redeemToken to mint then provide liquidity for.\r\n     * @param   quantityOptions The quantity of underlyingTokens to use to mint option + redeem tokens.\r\n     * @param   amountBMax The quantity of underlyingTokens to add with shortOptionTokens to the Uniswap V2 Pair.\r\n     * @param   amountBMin The minimum quantity of underlyingTokens expected to provide liquidity with.\r\n     * @param   to The address that receives UNI-V2 shares.\r\n     * @param   deadline The timestamp to expire a pending transaction.\r\n     */\r\n    function addShortLiquidityWithETH(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        public\r\n        payable\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(IOption(optionAddress))\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {c_0x4a07720e(0x2b00da8b34494486c8ddce1eb6f710695395d7b9efbd7ca740e818c135a482f6); /* function */ \n\r\nc_0x4a07720e(0xdab9b7cfdedb73ace43fdf1ec0ed6fc6292f6f5ee896e2fbcf030e2def0af833); /* line */ \n        c_0x4a07720e(0x9b07e5560dfdab699c85bfb8502d08a23917e9fe3007e817d3fee7706e1c2944); /* requirePre */ \nc_0x4a07720e(0x0c2b7258ad9b8d018ae8aeaa9432cd9c46abcf6f216cbedfd4f7327b826bc7e1); /* statement */ \nrequire(\r\n            quantityOptions.add(amountBMax) >= msg.value,\r\n            \"PrimitiveLiquidity: INSUFFICIENT\"\r\n        );c_0x4a07720e(0x88203d95419116b267a18616628861618a3d0ce637d448cf1b1a78cbd22a2e24); /* requirePost */ \n\r\n\r\nc_0x4a07720e(0x3a3df1754e87c1dc88fa9cfab619e38267978113fa0165d5fc88287778c82f8a); /* line */ \n        c_0x4a07720e(0x256b480692380a9cc598a51446545483f789a7f2eafb2e920c1198108ec7ff0f); /* statement */ \nuint256 amountA;\r\nc_0x4a07720e(0xfb91f5c0244d40ee783d1f261669f74ba0effa742f43539fa71b5f9b559d37d9); /* line */ \n        c_0x4a07720e(0x95347d4238300fdcb5f6008574897bcbd781fa1dbf81618b6cee61a3e7cf3af8); /* statement */ \nuint256 amountB;\r\nc_0x4a07720e(0x777e13f6212414cbf7448f4ac5b6caf4d298830f779676712e5b7e90406078f1); /* line */ \n        c_0x4a07720e(0xb06fc61601e18305e38c029250ba0c863c97e20e625584f7c6612a42bb417d1c); /* statement */ \nuint256 liquidity;\r\nc_0x4a07720e(0x4c728eea8125876c196c63075e00c39fe63b36c271597bf82c00e7ae7de50485); /* line */ \n        c_0x4a07720e(0x08b2e799883d5ca180b86bf7b7e1deb88d55f3ad14ef763c577fbb95e7c1343a); /* statement */ \naddress underlying = IOption(optionAddress).getUnderlyingTokenAddress();\r\nc_0x4a07720e(0xb9086ea558ff8cd278a958baf82db1bd367f78290c00ee6bac11cb08de77b83d); /* line */ \n        c_0x4a07720e(0xed225929f5d55743f5839b6027267a547b116e12f13a7248640eeb7bcd817851); /* requirePre */ \nc_0x4a07720e(0x2f7661e43a4643659f0654c0d46d4125ea06166614ae7a991772cb0d72762ecc); /* statement */ \nrequire(underlying == address(_weth), \"PrimitiveLiquidity: NOT_WETH\");c_0x4a07720e(0x1e069e35c8cca9f2f3a83bbb8111f05821f7ce425b85442c806ad202638df757); /* requirePost */ \n\r\n\r\nc_0x4a07720e(0xf188f8ceabd3dcbc13f9ccda3c71202454a4687b49efbc107542f3e3c4cb5cfc); /* line */ \n        c_0x4a07720e(0xbb11eb5b8c0392bf2c0e3190708aae97b68369073f7e2a2fb9de14fc3f06a84d); /* statement */ \n_depositETH(); // Wraps `msg.value` to Weth.\r\n        // Pushes Weth to option contract and mints option + redeem tokens to this contract.\r\nc_0x4a07720e(0x337494972c43615b82533caaf033622dae517d8ecee22b873fcfa21e011c969a); /* line */ \n        c_0x4a07720e(0x8aa6519827019289344e6e659019c0324d0e0de4d981ad0a87a09a81a4615d36); /* statement */ \nIERC20(underlying).safeTransfer(optionAddress, quantityOptions);\r\nc_0x4a07720e(0xf469e5b4337db52cc81c6ba417661a58edc895885b0445840736f853b59b9bcc); /* line */ \n        c_0x4a07720e(0x92511a50de61b52f7201a5d51b76f43e6803efcd4a735f581fc2381fd445a5d4); /* statement */ \n(, uint256 outputRedeems) = IOption(optionAddress).mintOptions(address(this));\r\n\r\nc_0x4a07720e(0x7db367b5c0391aa486b2501d3638a3c7e962b2f00fdaff74469c6559ec1ecf28); /* line */ \n        {\r\n            // scope for adding exact liquidity, avoids stack too deep errors\r\nc_0x4a07720e(0x03ab513208c01f07a79b22a07be243bac1aad3de7e42eefa248580e213568c58); /* line */ \n            c_0x4a07720e(0xd12360d6ac8bb716b1c50441ed114e359cecf5861aed5ac2e4376f94a6fdb7c4); /* statement */ \nIOption optionToken = IOption(optionAddress);\r\nc_0x4a07720e(0xff2d68e821a7786dcd5a3d8e59a87cd03834c2ea168486aa92eb846c5c8d0cff); /* line */ \n            c_0x4a07720e(0x3eccf6f6eec2ccbf9aa826666db1d22b3fd57c29afa2fc0d5f2f7500f463cb56); /* statement */ \naddress redeem = optionToken.redeemToken();\r\nc_0x4a07720e(0x2695c9698b3d8e6fd5d309983d8d6a6d7d6c15dfc1cf8f3f41105e1a3520eb41); /* line */ \n            c_0x4a07720e(0x426b95649a159cec1512409f0b72240a74307ec2480aee500430c7516734c16a); /* statement */ \nAddAmounts memory params;\r\nc_0x4a07720e(0x7bf177d24e74c08483683c424133b2061b96a5840639260e74499869d8c96c1d); /* line */ \n            c_0x4a07720e(0x1f3dfa60d3c54a0428672cc83906f77122d4cb586f1410d60499a8ec9cb1e6a6); /* statement */ \nparams.amountAMax = outputRedeems;\r\nc_0x4a07720e(0xd047f7012b63b83bf654a64730f48a41713984e30e08fb18cc1dd09f00e14ce8); /* line */ \n            c_0x4a07720e(0xb2189768de557153c2ce1db978a2665e1e1b6f188cd21db8bc5274872f0f79c7); /* statement */ \nparams.amountBMax = amountBMax;\r\nc_0x4a07720e(0x54b710276c268674f11427c1be17151cb6e4acc50c0dae7bc9f2a742a35fbe14); /* line */ \n            c_0x4a07720e(0xeba8c85f4a62d69b6f569b30a591c8b7f4317524bca11bd1e95833caf9724d6c); /* statement */ \nparams.amountAMin = outputRedeems;\r\nc_0x4a07720e(0x9994cb13ace8175c5d7dfccd29142c89aad7dc7c2b1676d229e8e6fb2290dfce); /* line */ \n            c_0x4a07720e(0x391677789009949ac76ec1afbf67c2b0c1e34e1aec03232c4c0f4202d6c5254c); /* statement */ \nparams.amountBMin = amountBMin;\r\nc_0x4a07720e(0xcca446fba2af06ddef20a077c0f13e2105a0f80c1ad54b5cb0ac2d465ed886f3); /* line */ \n            c_0x4a07720e(0xdd2ca85354c644cf044cea2f623090bcfc729b4147c66279aee05ef98db3ebaf); /* statement */ \nparams.deadline = deadline;\r\n\r\n            // Approves Uniswap V2 Pair pull tokens from this contract.\r\nc_0x4a07720e(0x8e77baf3d5bab8a5244e0c16091ba8a78cde3183708f969f58d49b260989f1c3); /* line */ \n            c_0x4a07720e(0x5277a37c33ee209a247606d9a00a7df2f650c9880d49f31697badf17a9dfd454); /* statement */ \ncheckApproval(redeem, address(_router));\r\nc_0x4a07720e(0x74f747a3d568eeefc2c4b01e36276b5472fbfbb5ab8e93a37a3223d1ef3d6d3d); /* line */ \n            c_0x4a07720e(0x5718e016e63ec0ec41a006bc2d287dfa97255544892ffe496b5f44a59426665c); /* statement */ \ncheckApproval(underlying, address(_router));\r\n            // Adds liquidity to Uniswap V2 Pair.\r\nc_0x4a07720e(0x56bd0fdf9543ffb82dd406110b70f4cac7d5e9f29f13a2ac2e8a35e4e6e66606); /* line */ \n            c_0x4a07720e(0x8a4283b7c5e20747cf5f734ca64758b3dc8512424ad29b67f0243ddc3d46a72e); /* statement */ \n(amountA, amountB, liquidity) = _addLiquidity(redeem, underlying, params);\r\nc_0x4a07720e(0x2edeecc93a009bca56676a1c2b29adb10bf4699cd1e4e9293a931c76ed89e2e3); /* line */ \n            c_0x4a07720e(0x5ce9f16350fd6c1d8a6acd40ab0ac933de597ad56ae4a1c9670c2a03cfdbb3e1); /* statement */ \nassert(amountA == outputRedeems); // Check for exact liquidity provided.\r\n            // Return remaining tokens and ether.\r\nc_0x4a07720e(0x4880aea6e57b1f29e4bcd0895121264466b525de7cead4e14b040b6c8a4ff409); /* line */ \n            c_0x4a07720e(0x837a010c9d0884e28606cfbf6fd03f31a2f3e7c088fb9b33c815d66c22d7aee8); /* statement */ \n_withdrawETH();\r\nc_0x4a07720e(0xcec873d744ee181d56eddd9e830598c4278a803795730f8400d417df8ccdfd4c); /* line */ \n            c_0x4a07720e(0x08e5de7d97dd66048d424fde5d0c6541c727d8baca90058ef3063d7f57a8942e); /* statement */ \n_transferToCaller(redeem);\r\nc_0x4a07720e(0x05ebfd7fe6690528a38995eac3cc2a9a712ab7d7e3da90727c15426f096c0586); /* line */ \n            c_0x4a07720e(0x1c4d0801e9f099649359b8fc37c6b6befca8b11510145a574d918d54a40832c7); /* statement */ \n_transferToCaller(address(optionToken));\r\n        }\r\nc_0x4a07720e(0x2c6467cf9efd840925609fcd7c5ce32c5960788a272e77c8e5dd04282e687d53); /* line */ \n        c_0x4a07720e(0xc21d1f5239d7ec0a1569c801df66b637061e8a2033b3bc9c975edeadd9f096e6); /* statement */ \nemit AddLiquidity(getCaller(), optionAddress, liquidity);\r\nc_0x4a07720e(0x4f48d7f04cc228efbf44f02721ceb15e949248069bebc0149c9d501413d6d995); /* line */ \n        c_0x4a07720e(0x858edafd02d0c8c18429b0872fd10fe86a6a131ea647d71b21d2f5ef7cd80bdc); /* statement */ \nreturn (amountA, amountB, liquidity);\r\n    }\r\n\r\n    struct AddAmounts {\r\n        uint256 amountAMax;\r\n        uint256 amountBMax;\r\n        uint256 amountAMin;\r\n        uint256 amountBMin;\r\n        uint256 deadline;\r\n    }\r\n\r\n    /**\r\n     * @notice  Calls UniswapV2Router02.addLiquidity() function using this contract's tokens.\r\n     * @param   tokenA The first token of the Uniswap Pair to add as liquidity.\r\n     * @param   tokenB The second token of the Uniswap Pair to add as liquidity.\r\n     * @param   params The amounts specified to be added as liquidity. Adds exact short options.\r\n     * @return  Returns the (amountTokenA, amountTokenB, liquidity).\r\n     */\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        AddAmounts memory params\r\n    )\r\n        internal\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {c_0x4a07720e(0xe93d4f80cb933a29c706682c107cb6b191bcf4220fde5264ff62927331a9bdc3); /* function */ \n\r\nc_0x4a07720e(0xacf0aba78762838e1318cb8de285dc963b0ac0738807ae9fcf64c94debec8707); /* line */ \n        c_0x4a07720e(0x6da022181180d2637c47803a439f06735e99b0d0721cb6f04482618462d80bdb); /* statement */ \nreturn\r\n            _router.addLiquidity(\r\n                tokenA,\r\n                tokenB,\r\n                params.amountAMax,\r\n                params.amountBMax,\r\n                params.amountAMin,\r\n                params.amountBMin,\r\n                getCaller(),\r\n                params.deadline\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev     Combines Uniswap V2 Router \"removeLiquidity\" function with Primitive \"closeOptions\" function.\r\n     * @notice  Pulls UNI-V2 liquidity shares with shortOption<>underlying token, and optionTokens from _msgSender().\r\n     *          Then closes the longOptionTokens and withdraws underlyingTokens to the \"getCaller()\" address.\r\n     *          Sends underlyingTokens from the burned UNI-V2 liquidity shares to the \"getCaller()\" address.\r\n     *          UNI-V2 -> optionToken -> underlyingToken.\r\n     * @param   optionAddress The address of the option that will be closed from burned UNI-V2 liquidity shares.\r\n     * @param   liquidity The quantity of liquidity tokens to pull from _msgSender() and burn.\r\n     * @param   amountAMin The minimum quantity of shortOptionTokens to receive from removing liquidity.\r\n     * @param   amountBMin The minimum quantity of underlyingTokens to receive from removing liquidity.\r\n     * @param   to The address that receives underlyingTokens from burned UNI-V2, and underlyingTokens from closed options.\r\n     * @param   deadline The timestamp to expire a pending transaction.\r\n     */\r\n    function removeShortLiquidityThenCloseOptions(\r\n        address optionAddress,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        public\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(IOption(optionAddress))\r\n        returns (uint256)\r\n    {c_0x4a07720e(0xd7e3c3e5585cfc3a1f0595a2379cc67e7fa98b52f7466bfd436ef730ce74e448); /* function */ \n\r\nc_0x4a07720e(0x969eb97331ef9e0ad09b0a43627e48b01a9bc250b16da5ca6e6804f68c57872a); /* line */ \n        c_0x4a07720e(0xe69f4cb10a87b350a26f3dbc5fff4827b49f247529da3f9ab6f80d05d73cbcc1); /* statement */ \nIOption optionToken = IOption(optionAddress);\r\nc_0x4a07720e(0xe138ba5421ae4f5fb6ccd30dd809dd25294d7e90364f2e0d2a0362c5f6da2a6f); /* line */ \n        c_0x4a07720e(0xffdad454462067106de60dd4e9156a3da7f3eca752c3c253f7be52efe8b95225); /* statement */ \n(IUniswapV2Pair pair, address underlying, address redeem) =\r\n            getOptionPair(optionToken);\r\n        // Gets amounts struct.\r\nc_0x4a07720e(0x974aef93cabf29f6b84507528ec71c5b16264cf3f53386131062f237a0772902); /* line */ \n        c_0x4a07720e(0x7624b482ed109c6ec0f38208468ce4a4012529e6df8283d4c55cd25c7b99beb5); /* statement */ \nRemoveAmounts memory params;\r\nc_0x4a07720e(0xc86ec69c4798054c061a24e3ee97259d5ea515c303548033d95a7b89fe902837); /* line */ \n        c_0x4a07720e(0xa594b4b7a5d73e3d0e93c567e39558cb4b1a43daae73fdcdafced87cf12fa5cc); /* statement */ \nparams.liquidity = liquidity;\r\nc_0x4a07720e(0x9f9f4595a30552fc68bf148bddb50968a6735e46468e83155a89c8bf4b27b3fa); /* line */ \n        c_0x4a07720e(0xf809f0f9879c320d4849dcb8e05d8eb622ac921b5ce70a1595395d024b087e08); /* statement */ \nparams.amountAMin = amountAMin;\r\nc_0x4a07720e(0x364e706f640a49e46f5b44fb3ff835d5eae8c312b38f2819c74504327378c29c); /* line */ \n        c_0x4a07720e(0x88aed9c0a85f1318ce0eee7ccd846ed7180e5c383e3d3a9824924955eff3d8ab); /* statement */ \nparams.amountBMin = amountBMin;\r\nc_0x4a07720e(0x7ed691bf1d8fcce45615499c03445580d68d47ffe4c4b56e1ca6e646765f5509); /* line */ \n        c_0x4a07720e(0x1838fd342c8e96e933f39a9d8cd7a4d73b4239809e2b03321d3733c4ea14a877); /* statement */ \nparams.deadline = deadline;\r\nc_0x4a07720e(0x9efce8a6c91c060190ed84d951a5fdfbc94d2f1654156c3051155aefee04eaac); /* line */ \n        c_0x4a07720e(0x5554f0f015847a88b25700f5f5efcc170aed68c8a01d6c6ea0488342e3b03ce1); /* statement */ \n_transferFromCaller(address(pair), liquidity); // Pulls lp tokens from `getCaller()`.\r\nc_0x4a07720e(0x5297847938b9772d20ef259e57c03327c0ab083a6acc2982d8a957cecaf5374b); /* line */ \n        c_0x4a07720e(0x807d5734f6bd78ab6a01af5c445b8943b5ab1b7234f53e8df798e0c81a9595d4); /* statement */ \ncheckApproval(address(pair), address(_router)); // Checks lp tokens can be pulled from here.\r\n        // Calls removeLiquidity on the UniswapV2Router02.\r\nc_0x4a07720e(0x9dfe4986a6687f3d4209e93153e93414c4ee2b19cc4de0d81b52bfaa5238c314); /* line */ \n        c_0x4a07720e(0xb8dc02c2972c37bd4ba9b71404f8e2f85031508512e6c653599cbf00c8b3f77f); /* statement */ \n(, uint256 underlyingAmount) = _removeLiquidity(redeem, underlying, params);\r\nc_0x4a07720e(0x56f2d7a1e448450285d12924ad0f1e1d0919d66e0fa66598bdecba3ef71dbc07); /* line */ \n        c_0x4a07720e(0x4cce05e27019b070c8dcb948ce820f5647595ca3698f3deff8eb97cf66303764); /* statement */ \nuint256 underlyingProceeds = _closeOptions(optionToken); // Returns amount of underlying tokens released.\r\n        // Return remaining tokens/ether.\r\nc_0x4a07720e(0xad1ebbcb4b7eb5cc3524b93696680e41f0ed4d178dc7416d621311e499832c6a); /* line */ \n        c_0x4a07720e(0x2cc38aedacdacaa0ad0000979abd5aedbea5ef59e4b7f13b5cab6fe6822da819); /* statement */ \n_transferToCaller(redeem); // Push any remaining redeemTokens from removing liquidity (dust).\r\nc_0x4a07720e(0x4a0f1d8ec22052b4505afdf145a4fa6e16c48df430d5075d0a02d3d2fb60a58d); /* line */ \n        c_0x4a07720e(0xf91a78541e5301afae7a6bd3f50446ef55f2f87ef97695f7570a87e8e1a4949b); /* statement */ \nif (underlying == address(_weth)) {c_0x4a07720e(0x68d90a49197f7d4713bee19d804a316cb3c16a5278c6a2a497c076349286ab1c); /* branch */ \n\r\nc_0x4a07720e(0x277f18df0879a313b7c9e0dbf758684ca237cf432099b34b9902952dc42786f1); /* line */ \n            c_0x4a07720e(0x1fd14eb9856c5acd00aa812b24eeab8f2749d806058c5abddcf03336fff11a02); /* statement */ \n_withdrawETH(); // Unwraps Weth and sends ether to `getCaller()`.\r\n        } else {c_0x4a07720e(0xc5550d0b6d49e85360ad7f5e83610893157621393a31ead0006154b6ff69fee6); /* branch */ \n\r\nc_0x4a07720e(0x5326584339e68f48f708bd592a51532e0becbfb5c602023432ac22985b2ce148); /* line */ \n            c_0x4a07720e(0x9a7557cbc08d6b7f3b7f8a30842f75278874edcd28049de08ddacfc986cd0bce); /* statement */ \n_transferToCaller(underlying); // Pushes underlying token to `getCaller()`.\r\n        }\r\nc_0x4a07720e(0xa4e1220faa340fd6dc4a9a4dcdd98fe8b4ec68b187837527997dfb9178c3fa45); /* line */ \n        c_0x4a07720e(0x5addd2d82bd7323e9147d884644e481928286c8d2ce47e2750cd53789cb3fb58); /* statement */ \nuint256 sum = underlyingProceeds.add(underlyingAmount); // Total underlyings sent to `getCaller()`.\r\nc_0x4a07720e(0x8cfa31a434c63b7454407e54553abfbf509aa03444acec237f40611c0d868292); /* line */ \n        c_0x4a07720e(0x2e9cd6b688886235b2546dd4305d084ab269ed1f5eb1c66d550694c4338b3ae2); /* statement */ \nemit RemoveLiquidity(getCaller(), address(optionToken), sum);\r\nc_0x4a07720e(0x8b0afdf510db57c44097692e285a794c4538b65a746d65c29a4442551793d2fc); /* line */ \n        c_0x4a07720e(0xd922282b09702e80f9175fb8f43beb0da5a2e7965572bd3fb354f325a6b6ecbc); /* statement */ \nreturn sum;\r\n    }\r\n\r\n    /**\r\n     * @notice  Pulls LP tokens, burns them, removes liquidity, pull option token, burns then, pushes all underlying tokens.\r\n     * @dev     Uses permit to pull LP tokens.\r\n     * @param   optionAddress The address of the option that will be closed from burned UNI-V2 liquidity shares.\r\n     * @param   liquidity The quantity of liquidity tokens to pull from _msgSender() and burn.\r\n     * @param   amountAMin The minimum quantity of shortOptionTokens to receive from removing liquidity.\r\n     * @param   amountBMin The minimum quantity of underlyingTokens to receive from removing liquidity.\r\n     * @param   to The address that receives underlyingTokens from burned UNI-V2, and underlyingTokens from closed options.\r\n     * @param   deadline The timestamp to expire a pending transaction and `permit` call.\r\n     */\r\n    function removeShortLiquidityThenCloseOptionsWithPermit(\r\n        address optionAddress,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external override onlyRegistered(IOption(optionAddress)) returns (uint256) {c_0x4a07720e(0xb8b0797acb71b2b24f4e08e6fae776352cec47f066f7c5418e9dd00db0902710); /* function */ \n\r\nc_0x4a07720e(0x6bb6a7824077291aad91a67c8a0a9f1854063fe8552df1796a7016140e9ebbe2); /* line */ \n        c_0x4a07720e(0x60c3d3d02ec2498d38bbdf361e411a1a391a2f486f42b14a179f2a3e9b9a8e90); /* statement */ \nIOption optionToken = IOption(optionAddress);\r\nc_0x4a07720e(0x79b18405bf6c8bda3fb0bd4e74b9f1fae7ae6d73a783981b2efebd21b625ebb1); /* line */ \n        c_0x4a07720e(0xcda772d8ec0be28e2cb0587a87ed01a6e7ca813bfc147d982a27cf11ee4163c1); /* statement */ \nuint256 liquidity_ = liquidity;\r\nc_0x4a07720e(0x4c52898a66a8d3670e0772a477f1793fe1487c3d69712c83988700f464d13463); /* line */ \n        c_0x4a07720e(0xec7c640ba3f48f9e9a71c177a9245b0c2620fada72cb2798a26f637cc25e06bd); /* statement */ \nuint256 deadline_ = deadline;\r\nc_0x4a07720e(0x04f51b82a75b919e355d83d802596b6999c4731a0366c999e6ff31b507959bdf); /* line */ \n        c_0x4a07720e(0x2a1f51a503bbaf60a2cf93624437e1b45c3b4d11c0fe03cd4939a9203cf352c4); /* statement */ \nuint256 amountAMin_ = amountAMin;\r\nc_0x4a07720e(0x87ea479dce26b5d271d3636a889fc8a63565598d9c550f08dead8b9e59d61064); /* line */ \n        c_0x4a07720e(0x616bf638d40fb8869fba2f57f6da49ffb32fba6ef23176f10082e9dcea15167f); /* statement */ \nuint256 amountBMin_ = amountBMin;\r\nc_0x4a07720e(0x632785d91cd29c473e2bb4ae651b154a61b0d6d0936137b45af53fdfba208019); /* line */ \n        c_0x4a07720e(0x31f2c3fdd6e22f7f3c01dc0d7222134d7ccccfe9b0042483625e64122014612f); /* statement */ \naddress to_ = to;\r\nc_0x4a07720e(0xd68c9840de8950d7e6ba66815de8808b1b3b2ac2c3cb148fdd0ef7e0ebe5348e); /* line */ \n        {\r\nc_0x4a07720e(0x888044a76255ed78cee5affcfb007b33d395897bc33c5aedfbe6184a3e3da2d2); /* line */ \n            c_0x4a07720e(0xac580669006d09eca2d6871f55ddce654aaba54a6afd518429415d25ad9e9576); /* statement */ \nuint8 v_ = v;\r\nc_0x4a07720e(0x9e7f5967664387642544bce9f41743ae3011f28bf57ad3d9f5ba0bfd39cb76f4); /* line */ \n            c_0x4a07720e(0xe712e5e16d0f18e15e8a796a8dc9b1fdedc5d31f83c4ed8942fbdf187796f156); /* statement */ \nbytes32 r_ = r;\r\nc_0x4a07720e(0xc57df1b03466b534c6930f71eea027422a3d14f65ce9fed5015163c0c8b30f82); /* line */ \n            c_0x4a07720e(0x5808caa5285ed297505e582730b2847429d97b080f126354d61c1c84d02ff144); /* statement */ \nbytes32 s_ = s;\r\nc_0x4a07720e(0xa5348dbb66309d9872ea0329d7fb7e7467656cd029190b2bb5764f2049df53de); /* line */ \n            c_0x4a07720e(0xcda6950f4b50b226b6410083d5a87d06adfa08a1082e7d60047edab5595cfcc0); /* statement */ \n(IUniswapV2Pair pair, , ) = getOptionPair(optionToken);\r\nc_0x4a07720e(0x0886df6bb1963518d92687ed9c3374704d2f79c0e568eb6aeef77f648a9c066c); /* line */ \n            c_0x4a07720e(0xea8e6a6a1694253f2783089276ebc128cdb48345367b79796827428d8aeb25c8); /* statement */ \npair.permit(\r\n                getCaller(),\r\n                address(_primitiveRouter),\r\n                liquidity_,\r\n                deadline_,\r\n                v_,\r\n                r_,\r\n                s_\r\n            );\r\n        }\r\nc_0x4a07720e(0xd52f5a7093b33fa411b37d5f9995461c65508a43cc6552b83708c808fef147cd); /* line */ \n        c_0x4a07720e(0x19d8f48ad58e493973278059db865ed4f1b533b5fa9c66e1bbda7b0b8259d028); /* statement */ \nreturn\r\n            removeShortLiquidityThenCloseOptions(\r\n                address(optionToken),\r\n                liquidity_,\r\n                amountAMin_,\r\n                amountBMin_,\r\n                to_,\r\n                deadline_\r\n            );\r\n    }\r\n\r\n    struct RemoveAmounts {\r\n        uint256 liquidity;\r\n        uint256 amountAMin;\r\n        uint256 amountBMin;\r\n        uint256 deadline;\r\n    }\r\n\r\n    /**\r\n     * @notice  Calls UniswapV2Router02.removeLiquidity() to burn LP tokens for pair tokens.\r\n     * @param   tokenA The first token of the pair.\r\n     * @param   tokenB The second token of the pair.\r\n     * @param   params The amounts to specify the amount to remove and minAmounts to withdraw.\r\n     * @return  Returns (amountTokenA, amountTokenB) to this contract.\r\n     */\r\n    function _removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        RemoveAmounts memory params\r\n    ) internal returns (uint256, uint256) {c_0x4a07720e(0x9349cb2751c4568a8ecee54d03ecd4ed51d57eae17b304dedd0ff7c90143e529); /* function */ \n\r\nc_0x4a07720e(0x5ebd9b2f0b233d2900fcf040141feb98ba7ff732dedf4c1056e6c88d85b3a41e); /* line */ \n        c_0x4a07720e(0xbcf117907c2f8fc8809e91bd69fad4417334f6c56e5fdb183fce5003ba4d0b40); /* statement */ \nreturn\r\n            _router.removeLiquidity(\r\n                tokenA,\r\n                tokenB,\r\n                params.liquidity,\r\n                params.amountAMin,\r\n                params.amountBMin,\r\n                address(this),\r\n                params.deadline\r\n            );\r\n    }\r\n\r\n    // ===== View =====\r\n\r\n    /**\r\n     * @notice  Gets the UniswapV2Router02 contract address.\r\n     */\r\n    function getRouter() public view override returns (IUniswapV2Router02) {c_0x4a07720e(0xa15bb76f72209fdcef4b0cda020add6c7afe2865485f60d338e8baceadeaaf28); /* function */ \n\r\nc_0x4a07720e(0x56414b7c7bd55c8f234887264cc9e821b114588d6b7a74bd564e9db6efba923f); /* line */ \n        c_0x4a07720e(0xb00f04161fa33dafc106d9d6bf1114ec3e463b3fdbb13ffb60b08178a07f448a); /* statement */ \nreturn _router;\r\n    }\r\n\r\n    /**\r\n     * @notice  Gets the UniswapV2Factory contract address.\r\n     */\r\n    function getFactory() public view override returns (IUniswapV2Factory) {c_0x4a07720e(0xa264c8764c26e6e9d0c8607f6ba84bdf24a8f6a0b2da78dec642d310b1e6a18f); /* function */ \n\r\nc_0x4a07720e(0x6abbc76eee39678ae05031859af9fccc2b6038bf83de1247f5257de261a270c0); /* line */ \n        c_0x4a07720e(0x4fddffeba4a3ec763f77e4a09c61596cbcf92867bc4e8499f283dc5ca4fd1b23); /* statement */ \nreturn _factory;\r\n    }\r\n\r\n    /**\r\n     * @notice  Fetchs the Uniswap Pair for an option's redeemToken and underlyingToken params.\r\n     * @param   option The option token to get the corresponding UniswapV2Pair market.\r\n     * @return  The pair address, as well as the tokens of the pair.\r\n     */\r\n    function getOptionPair(IOption option)\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            IUniswapV2Pair,\r\n            address,\r\n            address\r\n        )\r\n    {c_0x4a07720e(0x5b58056bd69779caf91518d8b098d3eb22924d0f451d1d6ce85e9d2113a32981); /* function */ \n\r\nc_0x4a07720e(0xe7664b1b79434bae5838d3064b430000b50b154550a92c64bb363079b5b94c34); /* line */ \n        c_0x4a07720e(0x53bc75a835c7e72052f21c8eaf1a3cf718a74607a7505badc4c9b2b0573d593d); /* statement */ \naddress redeem = option.redeemToken();\r\nc_0x4a07720e(0x15363e8c34b27f483bb8d130078dc5b83268b79b9579b5d6f76a6727316c02b2); /* line */ \n        c_0x4a07720e(0x9185ae3366c7180ed39dc8bbee7d1829f6b820c45a74f5cc234416d1afb5cace); /* statement */ \naddress underlying = option.getUnderlyingTokenAddress();\r\nc_0x4a07720e(0x786db4ccff382e93ecd097aeb428213ec4cd600abd0fab08dfaa6ad4ab7c96ab); /* line */ \n        c_0x4a07720e(0x89c068a10b7afe9801dc913f9df64c7855772c353b09970aebe6c4d8c1f059d2); /* statement */ \nIUniswapV2Pair pair = IUniswapV2Pair(_factory.getPair(redeem, underlying));\r\nc_0x4a07720e(0xc7e82c0bd79b330917771e0046092bd8d245de1f14830c77dc94f9b8179b54ca); /* line */ \n        c_0x4a07720e(0x796063e383664eb7e2067eef322645a50f2481e02318c1288c0ef40c4e0f979e); /* statement */ \nreturn (pair, underlying, redeem);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IPrimitiveLiquidity.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\nimport {\r\n    IUniswapV2Router02\r\n} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\r\nimport {\r\n    IUniswapV2Factory\r\n} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\r\nimport {IUniswapV2Pair} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\r\nimport {IOption} from \"@primitivefi/contracts/contracts/option/interfaces/IOption.sol\";\r\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\r\n\r\ninterface IPrimitiveLiquidity {\r\n    // ==== External ====\r\n\r\n    function addShortLiquidityWithUnderlying(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function addShortLiquidityWithETH(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function addShortLiquidityWithUnderlyingWithPermit(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function addShortLiquidityDAIWithPermit(\r\n        address optionAddress,\r\n        uint256 quantityOptions,\r\n        uint256 amountBMax,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function removeShortLiquidityThenCloseOptions(\r\n        address optionAddress,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function removeShortLiquidityThenCloseOptionsWithPermit(\r\n        address optionAddress,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256);\r\n\r\n    // ==== View ====\r\n\r\n    function getRouter() external view returns (IUniswapV2Router02);\r\n\r\n    function getFactory() external view returns (IUniswapV2Factory);\r\n\r\n    function getOptionPair(IOption option)\r\n        external\r\n        view\r\n        returns (\r\n            IUniswapV2Pair,\r\n            address,\r\n            address\r\n        );\r\n}\r\n"
    },
    "contracts/test/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   TestERC20\r\n * @author  Primitive\r\n * @notice  An opinionated ERC20 with `permit` to use ONLY for testing.\r\n * @dev     @primitivefi/v1-connectors@v2.0.0\r\n */\r\n\r\nimport {IERC20Permit} from \"../interfaces/IERC20Permit.sol\";\r\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\ncontract TestERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    string public name = \"Test Token\";\r\n    string public symbol;\r\n    uint8 public constant decimals = 18;\r\n    uint256 public totalSupply;\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    mapping(address => uint256) public nonces;\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint256 initialSupply\r\n    ) public {\r\n        name = name_;\r\n        symbol = symbol_;\r\n        _mint(msg.sender, initialSupply);\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\r\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n                ),\r\n                keccak256(bytes(name_)),\r\n                keccak256(bytes(\"1\")),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param to The address that will receive the minted tokens.\r\n     * @param value The amount of tokens to mint.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mint(address to, uint256 value) public returns (bool) {\r\n        _mint(to, value);\r\n        return true;\r\n    }\r\n\r\n    function _mint(address to, uint256 value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint256 value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 value\r\n    ) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) private {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint256 value) external returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 value) external returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool) {\r\n        if (allowance[from][msg.sender] != uint256(-1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(deadline >= block.timestamp, \"Primitive: EXPIRED\");\r\n        bytes32 digest =\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR,\r\n                    keccak256(\r\n                        abi.encode(\r\n                            PERMIT_TYPEHASH,\r\n                            owner,\r\n                            spender,\r\n                            value,\r\n                            nonces[owner]++,\r\n                            deadline\r\n                        )\r\n                    )\r\n                )\r\n            );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(\r\n            recoveredAddress != address(0) && recoveredAddress == owner,\r\n            \"Primitive: INVALID_SIGNATURE\"\r\n        );\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n"
    },
    "contracts/PrimitiveRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Router\r\n * @author  Primitive\r\n * @notice  Contract to execute Primitive Connector functions.\r\n * @dev     @primitivefi/v1-connectors@v2.0.0\r\n */\r\n\r\n// Open Zeppelin\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\";\r\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport {\r\n    IPrimitiveRouter,\r\n    IRegistry,\r\n    IOption,\r\n    IERC20,\r\n    IWETH\r\n} from \"./interfaces/IPrimitiveRouter.sol\";\r\n\r\n/**\r\n * @notice  Used to execute calls on behalf of the Router contract.\r\n * @dev     Changes `msg.sender` context so the Router is not `msg.sender`.\r\n */\r\ncontract Route {\nfunction c_0x7c2a953c(bytes32 c__0x7c2a953c) public pure {}\n\r\n    function executeCall(address target, bytes calldata params) external payable {c_0x7c2a953c(0x9c4d849b2871e09e62385b9cf24c0838dd4f2f8e10a6ab3074a55988bff8a7cc); /* function */ \n\r\nc_0x7c2a953c(0xd0785727c1022024a3e8b132d2c4a9ece6304546ccf582c8716beb7ee96fe6dd); /* line */ \n        c_0x7c2a953c(0xa8ba0f2b5683474988e6c0ee03bb051ea06383577a312c7225123ae8849f10b4); /* statement */ \n(bool success, bytes memory returnData) = target.call.value(msg.value)(params);\r\nc_0x7c2a953c(0xb99b54f82aba1f52a655b01b81c988e20b6f73a43cf7d8bb2e1984f10f6fe134); /* line */ \n        c_0x7c2a953c(0x184aaa7647f00566b35d7a856cca58b4c444444d2601c62a472a4b6349535c98); /* requirePre */ \nc_0x7c2a953c(0x8d9cf6c7ec15a68aa5bec70217573ed143c7334a8055473bc174dfdc3cded552); /* statement */ \nrequire(success, \"Route: EXECUTION_FAIL\");c_0x7c2a953c(0x1f823f23ba624923024770dfc15a4ab0b89f9f879f0e0232a9c27db091d59d2e); /* requirePost */ \n\r\n    }\r\n}\r\n\r\ncontract PrimitiveRouter is IPrimitiveRouter, Ownable, Pausable, ReentrancyGuard {\nfunction c_0x6da79448(bytes32 c__0x6da79448) public pure {}\n\r\n    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data.\r\n    using SafeMath for uint256; // Reverts on math underflows/overflows.\r\n\r\n    // Constants\r\n    address private constant _NO_CALLER = address(0x0); // Default state for `_CALLER`.\r\n\r\n    // Events\r\n    event Initialized(address indexed from); // Emmitted on deployment\r\n    event Executed(address indexed from, address indexed to, bytes params);\r\n    event RegisteredOptions(address[] indexed options);\r\n    event RegisteredConnectors(address[] indexed connectors, bool[] registered);\r\n\r\n    // State variables\r\n    IRegistry private _registry; // The Primitive Registry which deploys Option clones.\r\n    IWETH private _weth; // Canonical WETH9\r\n    Route private _route; // Intermediary to do connector.call() from.\r\n    address private _CONNECTOR = _NO_CALLER; // If _EXECUTING, the `connector` of the execute call param.\r\n    address private _CALLER = _NO_CALLER; // If _EXECUTING, the orginal `_msgSender()` of the execute call.\r\n    bool private _EXECUTING; // True if the `executeCall` function was called.\r\n\r\n    // Whitelisted mappings\r\n    mapping(address => bool) private _registeredConnectors;\r\n    mapping(address => bool) private _registeredOptions;\r\n\r\n    /**\r\n     * @notice  A mutex to use during an `execute` call.\r\n     * @dev     Checks to make sure the `_CONNECTOR` in state is the `msg.sender`.\r\n     *          Checks to make sure a `_CALLER` was set.\r\n     *          Fails if this modifier is triggered by an external call.\r\n     *          Fails if this modifier is triggered by calling a function without going through `executeCall`.\r\n     */\r\n    modifier isExec() {c_0x6da79448(0x92ed17c081bf405d519936002aecca1fc8805143ac0e2c8de2e8243928b443a6); /* function */ \n\r\nc_0x6da79448(0x7cfe3b563818e380bbb8c8fe9d84359cdfeb43d0a496e21085862d2fac4bc9ad); /* line */ \n        c_0x6da79448(0xa94d93d062acf04a002f0b47ebeee1c5971db67e62ee5eab46db324094b94e89); /* requirePre */ \nc_0x6da79448(0x1d1fd4f66c6075b2c86d042ca472551856054bf98bf40363a31485974aa25f9a); /* statement */ \nrequire(_CONNECTOR == _msgSender(), \"Router: NOT_CONNECTOR\");c_0x6da79448(0x3ed05ece24bb11358c395cbbdf581ebd2bfc684718991e11f85d8adf991d4c82); /* requirePost */ \n\r\nc_0x6da79448(0x2da3f72a706f74eaa16da02bc7ccb295dbf354c33d87f56c04a19ee90f73cc6d); /* line */ \n        c_0x6da79448(0x3485649866200dbe427f82389a7cde82a6040c220007a8ed785de47be19b2787); /* requirePre */ \nc_0x6da79448(0x59503ab6868c99c88a13fad164a3e018ef4b6b14c232ec2227972b4605c32e22); /* statement */ \nrequire(_CALLER != _NO_CALLER, \"Router: NO_CALLER\");c_0x6da79448(0x21dbd5605125a8f36f89be93a072247fee454f93cca6f00d0e7d0f2dc77363c2); /* requirePost */ \n\r\nc_0x6da79448(0x5bf1afd8abc022843924300335721d06256c3bb4debb9f43cf03da1c517df396); /* line */ \n        c_0x6da79448(0x8a24d8615d1ae6bed193ed72b9765c39dbad7d96ffeebc04f66b03e1b91f2119); /* requirePre */ \nc_0x6da79448(0x287a9c7f3e478d722452208738d94a6a19f8172d181ee411b8ae4b65561be2f4); /* statement */ \nrequire(!_EXECUTING, \"Router: IN_EXECUTION\");c_0x6da79448(0x6afb657839b59d353edcb229a90142442d335aee5fffe7994388c8837ea566af); /* requirePost */ \n\r\nc_0x6da79448(0x6f5d6979083b262b64bfa4a93a5433e6109b36da75543a867f0f4c03bf01b63c); /* line */ \n        c_0x6da79448(0x7a1d357cc8cfd8f074922477a81964b0a9b094cb5e7fa718e61b54764669d8a3); /* statement */ \n_EXECUTING = true;\r\nc_0x6da79448(0x51632bdbb35719266c68129f5c109b930f18c747d2e49370296a6f647b29d7af); /* line */ \n        _;\r\nc_0x6da79448(0x050f72b79c31b6b0470e380fa6b4bf89fa41f91f22cee410dbfd19e09efe7c78); /* line */ \n        c_0x6da79448(0x561c5a510aec282abb1e6cde2f8a2884144bd48d03893336170d2cbe95c89afb); /* statement */ \n_EXECUTING = false;\r\n    }\r\n\r\n    // ===== Constructor =====\r\n\r\n    constructor(address weth_, address registry_) public {c_0x6da79448(0x068b8ac395dad89d14af98dc8444b0def8dabcc70ba5717c4c545994ab35d3a0); /* function */ \n\r\nc_0x6da79448(0xb6851d82a2c8230e684319f079e63b95a4a31d5acc25716bb1988bd33273d52e); /* line */ \n        c_0x6da79448(0x85aa682ef7def270a9ad14d3d04cc8b9e61bd800ca78219a11e87deb9b9f205a); /* requirePre */ \nc_0x6da79448(0xceafa11f00b428a9ed586248b5806bcb05513ed515047d2b59fac0b602f1bb1a); /* statement */ \nrequire(address(_weth) == address(0x0), \"Router: INITIALIZED\");c_0x6da79448(0x0718c48c9920a146bc53e05d29318febffc116d27865888cf675da57a62c15d2); /* requirePost */ \n\r\nc_0x6da79448(0x6df14a3a32d49390d17dcc487bdff79fac80d04094bd3b2fbcca57da61b22428); /* line */ \n        c_0x6da79448(0x026f7a9bfd29bd910688f4b1691a0d9f12a1040c1ddb4eca6cf0fe195e0dd2d4); /* statement */ \n_route = new Route();\r\nc_0x6da79448(0x7b429ef6670f1816ad27c7cfc72a8159677e7d4a52a1c71398d9e877bb79eb0f); /* line */ \n        c_0x6da79448(0xb9829d6ac636a8d819145e6f52d14634da08f26cb76c0fba07eabd1396433648); /* statement */ \n_weth = IWETH(weth_);\r\nc_0x6da79448(0x55a6deb586b25eece4489f40f63c20bc9ac6be47648343ec5f9042478279f82c); /* line */ \n        c_0x6da79448(0x0ebed05ee643ef2f3264c953635e37c67d9d6dbec4936865f34197b7409ae946); /* statement */ \n_registry = IRegistry(registry_);\r\nc_0x6da79448(0x305ed0ec614a069510f6a3f0420bcd22d1cfa5ffa7b1de22cdb2569c27e91b24); /* line */ \n        c_0x6da79448(0xc6bcae7fc2fd42f662465d49d74ed7f3310066850439afb14b4414d13f668e64); /* statement */ \nemit Initialized(_msgSender());\r\n    }\r\n\r\n    // ===== Pausability =====\r\n\r\n    /**\r\n     * @notice  Halts use of `executeCall`, and other functions that change state.\r\n     */\r\n    function halt() external override onlyOwner {c_0x6da79448(0x660f2bfca9d5e60d3210371c96ae8856937ea08d5a22f37c6a6775ae23195da4); /* function */ \n\r\nc_0x6da79448(0x9d90eb3dd661ada59005c8b23ed2fae59e789a2ba2d725c4ae614c67e62e0caa); /* line */ \n        c_0x6da79448(0x59523070193ab988c72ddfbe23af470ebda3cca135b1030c730304c882096160); /* statement */ \nif (paused()) {c_0x6da79448(0x5aca7213c6de2d7a5955b7181728474a0a057e28d00cd7356832d7ff2a987d91); /* branch */ \n\r\nc_0x6da79448(0xa23dc4ceb5f2cda183b276b94316cc513cb36ad54a9cacc49636946eeca5090b); /* line */ \n            c_0x6da79448(0xc0262e3d2e554d34a577f85de075b257b3f1e21096cf660f99eee2e77828c4e4); /* statement */ \n_unpause();\r\n        } else {c_0x6da79448(0xbe3b4a02e00564f1191d999abb0514d205b59b03a488c933f484066d883a8734); /* branch */ \n\r\nc_0x6da79448(0xfa3f8de7f43985c8c7d97e5bc4c6b1a4513ba5f4fa8e9abc245f590cbe5d64d0); /* line */ \n            c_0x6da79448(0x652e2b338ca2cab96dad626b0a5136e227c417ad287e128bdf458977873a296b); /* statement */ \n_pause();\r\n        }\r\n    }\r\n\r\n    // ===== Registration =====\r\n\r\n    /**\r\n     * @notice  Checks option against Primitive Registry. If from Registry, registers as true.\r\n     *          NOTE: Purposefully does not have `onlyOwner` modifier.\r\n     * @dev     Sets `optionAddresses` to true in the whitelisted options mapping, if from Registry.\r\n     * @param   optionAddresses The array of option addresses to update.\r\n     */\r\n    function setRegisteredOptions(address[] calldata optionAddresses)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {c_0x6da79448(0x78b52be9ac45f680a35a0b4ce9c36ce6d327387234cced46404e93d2b3e63d1c); /* function */ \n\r\nc_0x6da79448(0xca70ee06bad2efbb65591fd25164a4c7d6a2cc2adc9de1d21c23ac30a37bb1c4); /* line */ \n        c_0x6da79448(0x5f21ed6e0474abd820ddd2be83f951dd19114085661bfa99a06ecfb8d8838c4f); /* statement */ \nuint256 len = optionAddresses.length;\r\nc_0x6da79448(0x1be804750ad4857ace9163668048c984831a047ef4e66e452b432661ce0a2c2c); /* line */ \n        c_0x6da79448(0xb94c177c3c2d3c520ad835c56093e69fceb392c2135b3730cf7459c575daf877); /* statement */ \nfor (uint256 i = 0; i < len; i++) {\r\nc_0x6da79448(0x700e7884b5c01e0d561bd8c60e9626667ec8800237247bc658530e8b12d539f5); /* line */ \n            c_0x6da79448(0x2703c521c3e6f87be131c990c48fadc4ba6bff052b1c85698ae4635ebbb07170); /* statement */ \naddress option = optionAddresses[i];\r\nc_0x6da79448(0xa1963ec3113102d06bc65970735edfdb63d7303bf450f42366fade8f13aa4bd0); /* line */ \n            c_0x6da79448(0xc330e03cfae6e0ae1485b2b7a88a57310269c3ae79d0ba71cb9601b4f2df2bb5); /* requirePre */ \nc_0x6da79448(0x027f2f2bfbd602f9cf545b4da16488ff79e437844b685256d300242696a359b4); /* statement */ \nrequire(isFromPrimitiveRegistry(IOption(option)), \"Router: EVIL_OPTION\");c_0x6da79448(0x3a29b95b8dad6a20f8111e4005e4b409254798f709eb05f4f844b69d4d6c42ff); /* requirePost */ \n\r\nc_0x6da79448(0xb8c38486c30bfad2cb54d0ea30cd6cb7b20c48aa4849661bf1a8b467b0e84814); /* line */ \n            c_0x6da79448(0x11b46947ba664dfd410ff92da1b0c9970a425e744bf1f00b659522ea0f29ee56); /* statement */ \n_registeredOptions[option] = true;\r\n        }\r\nc_0x6da79448(0x5969c2a527dd280d3ce49e829b9d6e15f337ccf3edb8cbde15e7c672b056b0a0); /* line */ \n        c_0x6da79448(0x02442742e7ce6ef63c1f22c4866bf8dc4c3bdc459c41b267408743483619ec2e); /* statement */ \nemit RegisteredOptions(optionAddresses);\r\nc_0x6da79448(0xc2c322362889d3fc76e1a55d252cebeae71bacf6e73567f3b087501d81614239); /* line */ \n        c_0x6da79448(0x421a95a37f65d7a28b96d9f9febb75313dc37730885f2403c7b04f3bf8c64061); /* statement */ \nreturn true;\r\n    }\r\n\r\n    /**\r\n     * @notice  Allows the `owner` to set whitelisted connector contracts.\r\n     * @dev     Sets `connectors` to `isValid` in the whitelisted connectors mapping.\r\n     * @param   connectors The array of option addresses to update.\r\n     * @param   isValid Whether or not the optionAddress is registered.\r\n     */\r\n    function setRegisteredConnectors(address[] memory connectors, bool[] memory isValid)\r\n        public\r\n        override\r\n        onlyOwner\r\n        returns (bool)\r\n    {c_0x6da79448(0xb244a45e680b62369aa93135d25d544dc822459c6a9024a2b6358509fe44dcbb); /* function */ \n\r\nc_0x6da79448(0x3efb5a448e2aab253c80095cb5a38e34d1ea258d971673e8ceaf4fc3a8bb020c); /* line */ \n        c_0x6da79448(0x08886b1441ab2cd44a8bb88b0c6a64953349826955b33bcd778e30336aea9f55); /* statement */ \nuint256 len = connectors.length;\r\nc_0x6da79448(0x67c7c86bdc715a4c5745c6b786a68a94080b74db929cb37c7bd8e719b0fe1778); /* line */ \n        c_0x6da79448(0x0df1e7660e657797ec79fd3396dcd3dd9d58ffd3e7841c6644a96976cef70427); /* requirePre */ \nc_0x6da79448(0x56447c0e6d737a9e2d6c540b1e8030a3d1f7be0a6f8ce8e9711827b9077b507b); /* statement */ \nrequire(len == isValid.length, \"Router: LENGTHS\");c_0x6da79448(0x15d5cf00c303748c22050a74c8ea2081c68bbb1ded3f7256dfb2687847102494); /* requirePost */ \n\r\nc_0x6da79448(0x8424e039362a714a603e9a7b7030631139a28dba670ecbd9743881b1421c0288); /* line */ \n        c_0x6da79448(0x38e489a05cf81f6109b18ae45884d981b854c31635c2508297b45c6b719ce76e); /* statement */ \nfor (uint256 i = 0; i < len; i++) {\r\nc_0x6da79448(0xa4ce65e9ce70564e91c03f446182ab1f5f99adccf82d72e63086bff181b81e2f); /* line */ \n            c_0x6da79448(0x9abc1a9f9b5b4ffe3be65fdd60b2bb5908fb169303d0743a5ccb9587b4d438f1); /* statement */ \naddress connector = connectors[i];\r\nc_0x6da79448(0xf0b46c9e19e4af50df64924072540da1046f1957c664608df66d31392f381f76); /* line */ \n            c_0x6da79448(0x8a019c995660394e75ca2afee2736dc2a03fd061bdb2b1a754b0322dd35a269c); /* statement */ \nbool status = isValid[i];\r\nc_0x6da79448(0x4c9a87e9b583932184cf47b9f6183f30f9c42938910499a79bf112e7e0366c5f); /* line */ \n            c_0x6da79448(0x1ef85027ae5b4ee939fde63e9da0807bf3fc828d1b87eccbe29a349d36e8cc1d); /* statement */ \n_registeredConnectors[connector] = status;\r\n        }\r\nc_0x6da79448(0x6bfb99fbf34267524ae5b495fde72efc8f09c966c0882f850a339147e12a1d79); /* line */ \n        c_0x6da79448(0xd71f835d4f9ef5e2cb0eb368028e0c4813c8b29502456887f9ba49fd78f5c044); /* statement */ \nemit RegisteredConnectors(connectors, isValid);\r\nc_0x6da79448(0xadecd20fc0c4c0371087519a829997dd3844d4c3722f71c15fecdbbafc507146); /* line */ \n        c_0x6da79448(0x73ddbfbec7e018c5c7ad03ac3dce5382ff3a72e4f5aef426403b8bf6742e0444); /* statement */ \nreturn true;\r\n    }\r\n\r\n    /**\r\n     * @notice  Checks an option against the Primitive Registry.\r\n     * @param   option The IOption token to check.\r\n     * @return  Whether or not the option was deployed from the Primitive Registry.\r\n     */\r\n    function isFromPrimitiveRegistry(IOption option) internal view returns (bool) {c_0x6da79448(0xf5154eee2b272576be66b4ff73a078e29e6b0dc975d60fadb79eb6cd06dac4b6); /* function */ \n\r\nc_0x6da79448(0xa345e2bb1c37e948471906949476a134d2b01b17e5f662754ba8f38b72721324); /* line */ \n        c_0x6da79448(0x9cf739a62ef8378ad51c7754a92cd498ea26c0c0bc3403842f1c56085fc04d82); /* statement */ \nreturn (address(option) ==\r\n            _registry.getOptionAddress(\r\n                option.getUnderlyingTokenAddress(),\r\n                option.getStrikeTokenAddress(),\r\n                option.getBaseValue(),\r\n                option.getQuoteValue(),\r\n                option.getExpiryTime()\r\n            ) &&\r\n            address(option) != address(0));\r\n    }\r\n\r\n    // ===== Operations =====\r\n\r\n    /**\r\n     * @notice  Transfers ERC20 tokens from the executing `_CALLER` to the executing `_CONNECTOR`.\r\n     * @param   token The address of the ERC20.\r\n     * @param   amount The amount of ERC20 to transfer.\r\n     * @return  Whether or not the transfer succeeded.\r\n     */\r\n    function transferFromCaller(address token, uint256 amount)\r\n        public\r\n        override\r\n        isExec\r\n        whenNotPaused\r\n        returns (bool)\r\n    {c_0x6da79448(0xfb6917c3802162a0fd876267daaa5e584e15f9e842a3edc6268208ee757f6ccc); /* function */ \n\r\nc_0x6da79448(0x0954027f5d5825ee3b1d0084a870e6abbcaa235555a216df000f13b0c4f17536); /* line */ \n        c_0x6da79448(0x77a182dfc58046d9000901c448070fba75731665392e1d639dc2a05e853dbd68); /* statement */ \nIERC20(token).safeTransferFrom(\r\n            getCaller(), // Account to pull from\r\n            _msgSender(), // The connector\r\n            amount\r\n        );\r\nc_0x6da79448(0x74dcf01c466411ea717282040a4600e4412f52cda3cf4e7fbc84c7a19d17fa99); /* line */ \n        c_0x6da79448(0x747c23ad932bfed088374eaebefff995d06af1fc31d020eb3626a7435450352b); /* statement */ \nreturn true;\r\n    }\r\n\r\n    /**\r\n     * @notice  Transfers ERC20 tokens from the executing `_CALLER` to an arbitrary address.\r\n     * @param   token The address of the ERC20.\r\n     * @param   amount The amount of ERC20 to transfer.\r\n     * @return  Whether or not the transfer succeeded.\r\n     */\r\n    function transferFromCallerToReceiver(\r\n        address token,\r\n        uint256 amount,\r\n        address receiver\r\n    ) public override isExec whenNotPaused returns (bool) {c_0x6da79448(0x7acffeee7d46c939e3601224b2f3dc1e255b2da96c62179b58c5573a41ab62ee); /* function */ \n\r\nc_0x6da79448(0x0993c1ed52b6b0897470b2a8dd79bac3b712787eecac0b489ef605b11168a494); /* line */ \n        c_0x6da79448(0x3881930369f6e2e5bdfe60a391f578b2450fdcfab262204a0477003dfd5bb775); /* statement */ \nIERC20(token).safeTransferFrom(\r\n            getCaller(), // Account to pull from\r\n            receiver,\r\n            amount\r\n        );\r\nc_0x6da79448(0x7df13583621518b7849b75a1e657068014ea5e38aa52810a8ea369ea156f3642); /* line */ \n        c_0x6da79448(0xa2616a1a18691f1cb3ba2aa487c09a7f1930c5992f0f1b4bb37fc38b10c38112); /* statement */ \nreturn true;\r\n    }\r\n\r\n    // ===== Execute =====\r\n\r\n    /**\r\n     * @notice  Executes a call with `params` to the target `connector` contract from `_route`.\r\n     * @param   connector The Primitive Connector module to call.\r\n     * @param   params The encoded function data to use.\r\n     */\r\n    function executeCall(address connector, bytes calldata params)\r\n        external\r\n        payable\r\n        override\r\n        whenNotPaused\r\n    {c_0x6da79448(0x76eaad7884c3f6aa278e8da8ee4e0d1c252e4765141743ffc88a728f35fbff8f); /* function */ \n\r\nc_0x6da79448(0x718eb33cbf55e1c1d2bf19de3ebca7e56221b5b48f5e10eb66bb0341785187b0); /* line */ \n        c_0x6da79448(0x235ed6dd35313940704a931cc50a081020ba1947be716b1b277a6b5883ac4074); /* requirePre */ \nc_0x6da79448(0x583d74f14921cf7be9cf2185ec58d7b13df22bc67dcfe862c47a9aac01eb9f93); /* statement */ \nrequire(_registeredConnectors[connector], \"Router: INVALID_CONNECTOR\");c_0x6da79448(0x69b3aa7af7ca81d5b8b6536d17eba14fb8e84e74d1d3f2a45197c51b7444c396); /* requirePost */ \n\r\nc_0x6da79448(0xdebdb5961815661906c14f5b84a227dea86c8b3c433e35fc4b5b5da8da54700f); /* line */ \n        c_0x6da79448(0x0191b9116150e0fd2ffbe69dc26b84389750f3aee8c077c56616d386ee21cfdd); /* statement */ \n_CALLER = _msgSender();\r\nc_0x6da79448(0xb9a8a4190715180b6d4359ccf6249a261ca23c3ddb3360f9e14c247174c5715f); /* line */ \n        c_0x6da79448(0xe899480779ef762533858b18861ee1ab36d49b2972430727dd5f401ae3afecbf); /* statement */ \n_CONNECTOR = connector;\r\nc_0x6da79448(0xbfa35afdc12d6e231c04cea3e4124a604bc5ba0972cfda572386e4663e3b743c); /* line */ \n        c_0x6da79448(0x99cd3d03191ec1d68452700321cadae63745c48d61ec4a832133bed0661cb2a6); /* statement */ \n_route.executeCall.value(msg.value)(connector, params);\r\nc_0x6da79448(0xe81fbf7d8a3bc1ccfd67493c97c8c3782153ff564c86e54cfd674f3baf24d32c); /* line */ \n        c_0x6da79448(0x888839e78f3f3b6928ca1a1786f63168bb8cc764df65a910f2edfdb382ff1523); /* statement */ \n_CALLER = _NO_CALLER;\r\nc_0x6da79448(0xfa9b7899bf7775856d8c18b1fe3daa120e95ca7206469015ce4fe626920b59b3); /* line */ \n        c_0x6da79448(0x97eeb82c5ac2a6ff7166255d0ffd92a152f8c190695cd61c127e8b03ac17a664); /* statement */ \n_CONNECTOR = _NO_CALLER;\r\nc_0x6da79448(0x0ad45da55232ee6152e1f292ee1fbeed65b514543c260fdf1b1260369432a23b); /* line */ \n        c_0x6da79448(0xfa104f7a4113dece798dc5098327e495d330796de45d5a84d293c8238eb77a53); /* statement */ \nemit Executed(_msgSender(), connector, params);\r\n    }\r\n\r\n    // ===== Fallback =====\r\n\r\n    receive() external payable whenNotPaused {\r\nc_0x6da79448(0x5f64673d8670fde0a3a5dff5961e19c5cb5828eef1d4dba0ed98097847d8e2c0); /* line */ \n        assert(_msgSender() == address(_weth)); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    // ===== View =====\r\n\r\n    /**\r\n     * @notice  Returns the IWETH contract address.\r\n     */\r\n    function getWeth() public view override returns (IWETH) {c_0x6da79448(0xf9b847c28a420128d53b4f4e7774ff8b31a0203fad35bd70555ed65d618516cd); /* function */ \n\r\nc_0x6da79448(0xdd1e53107295d827683e6422f96b29c2a1125ecf9e49fb4dd61e53ce9ab7d5a5); /* line */ \n        c_0x6da79448(0x9b06c08e62070cf4e84b0ddf3813469445508e393be0a45b3cff4dfdebec567b); /* statement */ \nreturn _weth;\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns the Route contract which executes functions on behalf of this contract.\r\n     */\r\n    function getRoute() public view override returns (address) {c_0x6da79448(0x719a7b4a665200e5d80617182ff0f2d4aec090453c7aefcfafcae6f409f21274); /* function */ \n\r\nc_0x6da79448(0xd8d5a8740c3199dc2633fd089e9c74c2e801e7cdc3681ab3a749c1b6606de89f); /* line */ \n        c_0x6da79448(0x611b3b4a6d6d3deed8e0ca42c9fc6cacd68ba7d164d5a11e41fa5d67e1b18de9); /* statement */ \nreturn address(_route);\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns the `_CALLER` which is set to `_msgSender()` during an `executeCall` invocation.\r\n     */\r\n    function getCaller() public view override returns (address) {c_0x6da79448(0x3699f6b63392c31bc02a98fe83683f8051c90b45eda564b7deb437e2fafe9124); /* function */ \n\r\nc_0x6da79448(0xe54935ce39f7e28b20590cf2608afdf221db3d99f195d952f269ec5b0cd170f3); /* line */ \n        c_0x6da79448(0xa10b7b71b2ca8aa4b973de3a26a9adec911f6be197200f2094d973f3bfdb5f21); /* statement */ \nreturn _CALLER;\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns the Primitive Registry contract address.\r\n     */\r\n    function getRegistry() public view override returns (IRegistry) {c_0x6da79448(0x6a541aa2c42fee16b6864edb7f258de06c60d880d2f48aa84790b8c5b67f613e); /* function */ \n\r\nc_0x6da79448(0x0d588355869d55741f9191c6c215b3480d0094ad3e09818e58dee10ade39c91a); /* line */ \n        c_0x6da79448(0x31316f433abbd0bb787c70fa611688189f40b11c40ed855ae0308b14077e9557); /* statement */ \nreturn _registry;\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns a bool if `option` is registered or not.\r\n     * @param   option The address of the Option to check if registered.\r\n     */\r\n    function getRegisteredOption(address option) external view override returns (bool) {c_0x6da79448(0x84da62a1e3ef75d91718c625a75a087b760c3478bb308eb38b97e3b0b91ad41c); /* function */ \n\r\nc_0x6da79448(0x93aebd30d8993a6b6c73bb44b87befcf76d45a70049ac7dec01097d3a21a2db5); /* line */ \n        c_0x6da79448(0x0123e8607e095fbd2c2b8fd23c12b3461ceee3f0bc71e07519b18aec699ea667); /* statement */ \nreturn _registeredOptions[option];\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns a bool if `connector` is registered or not.\r\n     * @param   connector The address of the Connector contract to check if registered.\r\n     */\r\n    function getRegisteredConnector(address connector)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {c_0x6da79448(0x66658b248a06ae252aab7d09a320f5f08b1f94453bf58d5e70d348a6223d18aa); /* function */ \n\r\nc_0x6da79448(0x9aec240e4ce46a31103bf0591b399a0814b58a977bc654b68e90405aeefb8f58); /* line */ \n        c_0x6da79448(0x186dda43d33f675e69fce31a6d70fbbadfe1b13bec0f9ff35791abab59b8eb06); /* statement */ \nreturn _registeredConnectors[connector];\r\n    }\r\n\r\n    /**\r\n     * @notice  Returns the NPM package version and github version of this contract.\r\n     * @dev     For the npm package: @primitivefi/v1-connectors\r\n     *          For the repository: github.com/primitivefinance/primitive-v1-connectors\r\n     * @return  The apiVersion string.\r\n     */\r\n    function apiVersion() public pure override returns (string memory) {c_0x6da79448(0x8e9e988b50a48b349c0f90f398fd688f8642784b6aed383fb80d13e8a4106a97); /* function */ \n\r\nc_0x6da79448(0x039b0c104f649c33f0e0c4f51f6b96f5fe2810c18c7694fbff54fc4486bcd1bb); /* line */ \n        c_0x6da79448(0xe33327d453dc9f713cda55c1e515064caad986767f61612e9b71e311cf632b23); /* statement */ \nreturn \"2.0.0\";\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/test/PrimitiveRouterTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Router Test\r\n * @author  Primitive\r\n * @notice  A Test Contract Version of the Primitive Router for Custom Uniswap Addresses\r\n * @dev     @primitivefi/v1-connectors@v2.0.0\r\n */\r\n\r\nimport {PrimitiveRouter} from \"../PrimitiveRouter.sol\";\r\n\r\ncontract PrimitiveRouterTest is PrimitiveRouter {\r\n    constructor(\r\n        address weth_,\r\n        address router_,\r\n        address factory_,\r\n        address registry_\r\n    ) public PrimitiveRouter(weth_, registry_) {}\r\n}\r\n"
    },
    "contracts/interfaces/IPrimitiveCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\nimport {IOption} from \"@primitivefi/contracts/contracts/option/interfaces/IOption.sol\";\r\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\r\n\r\ninterface IPrimitiveCore {\r\n    // ===== External =====\r\n\r\n    function safeMintWithETH(IOption optionToken)\r\n        external\r\n        payable\r\n        returns (uint256, uint256);\r\n\r\n    function safeMintWithPermit(\r\n        IOption optionToken,\r\n        uint256 amount,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256, uint256);\r\n\r\n    function safeExerciseWithETH(IOption optionToken)\r\n        external\r\n        payable\r\n        returns (uint256, uint256);\r\n\r\n    function safeExerciseForETH(IOption optionToken, uint256 exerciseQuantity)\r\n        external\r\n        returns (uint256, uint256);\r\n\r\n    function safeRedeemForETH(IOption optionToken, uint256 redeemQuantity)\r\n        external\r\n        returns (uint256);\r\n\r\n    function safeCloseForETH(IOption optionToken, uint256 closeQuantity)\r\n        external\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n}\r\n"
    },
    "contracts/connectors/PrimitiveCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copyright 2021 Primitive Finance\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n// this software and associated documentation files (the \"Software\"), to deal in\r\n// the Software without restriction, including without limitation the rights to\r\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n// of the Software, and to permit persons to whom the Software is furnished to do\r\n// so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in all\r\n// copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\n\r\npragma solidity 0.6.2;\r\n\r\n/**\r\n * @title   Primitive Core\r\n * @author  Primitive\r\n * @notice  A Connector with Ether abstractions for Primitive Option tokens.\r\n * @dev     @primitivefi/v1-connectors@v2.0.0\r\n */\r\n\r\n// Open Zeppelin\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n// Primitive\r\nimport {CoreLib, SafeMath} from \"../libraries/CoreLib.sol\";\r\nimport {IPrimitiveCore, IERC20Permit, IOption} from \"../interfaces/IPrimitiveCore.sol\";\r\nimport {PrimitiveConnector} from \"./PrimitiveConnector.sol\";\r\n\r\ncontract PrimitiveCore is PrimitiveConnector, IPrimitiveCore, ReentrancyGuard {\nfunction c_0x27025830(bytes32 c__0x27025830) public pure {}\n\r\n    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\r\n    using SafeMath for uint256; // Reverts on math underflows/overflows\r\n\r\n    event Initialized(address indexed from); // Emmitted on deployment\r\n    event Minted(\r\n        address indexed from,\r\n        address indexed option,\r\n        uint256 longQuantity,\r\n        uint256 shortQuantity\r\n    );\r\n    event Exercised(address indexed from, address indexed option, uint256 quantity);\r\n    event Redeemed(address indexed from, address indexed option, uint256 quantity);\r\n    event Closed(address indexed from, address indexed option, uint256 quantity);\r\n\r\n    // ===== Constructor =====\r\n\r\n    constructor(address weth_, address primitiveRouter_)\r\n        public\r\n        PrimitiveConnector(weth_, primitiveRouter_)\r\n    {c_0x27025830(0x7ca2142b34d96bfcdbcd337d4f23def1f16af40ab905591a3e5d78d72116035a); /* function */ \n\r\nc_0x27025830(0xe22a982c7e6a0ba1b2869d468ce8e7705b140809cff091931a05848afbc65867); /* line */ \n        c_0x27025830(0xb1192645357b870dc21a951e87b948be5c0621fa0d70c3beb1b843f302c6ae83); /* statement */ \nemit Initialized(_msgSender());\r\n    }\r\n\r\n    // ===== Weth Abstraction =====\r\n\r\n    /**\r\n     * @dev     Mints msg.value quantity of options and \"quote\" (option parameter) quantity of redeem tokens.\r\n     * @notice  This function is for options that have WETH as the underlying asset.\r\n     * @param   optionToken The address of the option token to mint.\r\n     * @return  (uint, uint) Returns the (long, short) option tokens minted\r\n     */\r\n    function safeMintWithETH(IOption optionToken)\r\n        external\r\n        payable\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(optionToken)\r\n        returns (uint256, uint256)\r\n    {c_0x27025830(0x060d8f030e8c19ac3707baea9849eaad475d0151e92840435f44c114af2fdd2f); /* function */ \n\r\nc_0x27025830(0x0bd2cfce8ba3ca8307bfebf230275bddeb375ad7860e266466c5c22f2b993ebb); /* line */ \n        c_0x27025830(0x463cb35f163de3ecffa1f4a71c47f25be6bc4383f161221c7794d830c5d4081e); /* requirePre */ \nc_0x27025830(0x6864959900a6d5f831839026a3abd181e3a45f5ca7aa8cb333d0b68a3423dcc9); /* statement */ \nrequire(msg.value > 0, \"PrimitiveCore: ERR_ZERO\");c_0x27025830(0x21bdf520a002f91d309b01d8615283dd924f4ffe571616cdef471d7a7da409ad); /* requirePost */ \n\r\nc_0x27025830(0x84e3d2ff3606ea1af98651f205be1959bf0e82b59c541797ae6cd7284241295f); /* line */ \n        c_0x27025830(0x6c00d93a24682eca4d56123de37edf258ef623f8178256146724312dbcee9eae); /* statement */ \naddress caller = getCaller();\r\nc_0x27025830(0x0dbec9b0a177fb378fca110fba3c02570aea50e7a797aa395f4f0fc3b509f23a); /* line */ \n        c_0x27025830(0x68dd27df9b3792a220951154ba2f090469895951f90cdfff39f7c116ddccc724); /* statement */ \n_depositETH(); // Deposits `msg.value` to Weth contract.\r\nc_0x27025830(0xcfd9e1aafa962328e73d8437f61cf4477ae48e7747c8234e33f15c7a2e061373); /* line */ \n        c_0x27025830(0xeb97ab01ff7289a96bb8bd83cc71bf07f4aefc2f65b57eba95bdb7946137c8ac); /* statement */ \n(uint256 long, uint256 short) = _mintOptionsToReceiver(optionToken, caller);\r\nc_0x27025830(0xf97c81b868e3b318d0b1781093d9d2bbb223331684c309b9b731e4eeebf19b6e); /* line */ \n        c_0x27025830(0x5db2ee84d4299b6eb3644727350d79c17d8305e4ae0c737ed5fc8400a1d3ac05); /* statement */ \nemit Minted(caller, address(optionToken), long, short);\r\nc_0x27025830(0x235e042939924a2562fa18eaadd02304c1eae6412aa22576383f6b10aeae36df); /* line */ \n        c_0x27025830(0x4c59a0673512b5aef43297412516fe40e1ab689ac2ac3e3bc75a0dd04a8c4210); /* statement */ \nreturn (long, short);\r\n    }\r\n\r\n    /**\r\n     * @dev     Mints \"amount\" quantity of options and \"quote\" (option parameter) quantity of redeem tokens.\r\n     * @notice  This function is for options that have an EIP2612 (permit) enabled token as the underlying asset.\r\n     * @param   optionToken The address of the option token to mint.\r\n     * @param   amount The quantity of options to mint.\r\n     * @param   deadline The timestamp which expires the `permit` call.\r\n     * @return  (uint, uint) Returns the (long, short) option tokens minted\r\n     */\r\n    function safeMintWithPermit(\r\n        IOption optionToken,\r\n        uint256 amount,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(optionToken)\r\n        returns (uint256, uint256)\r\n    {c_0x27025830(0xb0f5614b732183c098c692881caeed7e0fdf8c3852a4f06a32c3be41141e6931); /* function */ \n\r\n        // Permit minting using the caller's underlying tokens.\r\nc_0x27025830(0x2069d14732fa49f5d44778fab6ff003aecbbab74bff18ae1881e3cc548460c45); /* line */ \n        c_0x27025830(0x6ac0fb46d9db20942bfd811eb6f50b0d5ce768b31f4a5405c10cbe11d6f534bf); /* statement */ \nIERC20Permit(optionToken.getUnderlyingTokenAddress()).permit(\r\n            getCaller(),\r\n            address(_primitiveRouter),\r\n            amount,\r\n            deadline,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\nc_0x27025830(0xc1c1640565a23f8bd8dbf44a2a25d83681c677f31388fcf65eaa8eeca708e0cd); /* line */ \n        c_0x27025830(0x0e71d283679bbf90eda79f78f3a76356e925553493e6b25a3a3aca5c2ddb7d9a); /* statement */ \n(uint256 long, uint256 short) = _mintOptionsFromCaller(optionToken, amount);\r\nc_0x27025830(0x6bb692cbe7b1de76901ae03b63f97801e195a9415a2ffc31673838b348803a32); /* line */ \n        c_0x27025830(0x5ef75daa199b65c5267cf1dcf4edd2ec965b1b77261b2c34d5d1db6b670c78f5); /* statement */ \nemit Minted(getCaller(), address(optionToken), long, short);\r\nc_0x27025830(0x9051f54247489b202e314ba0801fe28a82a5512a838f7976370bc4f6a62430f4); /* line */ \n        c_0x27025830(0x3d70a1405c3f0245332bebeb097787209bde3b5c9ae749297f4bb9016cec7322); /* statement */ \nreturn (long, short);\r\n    }\r\n\r\n    /**\r\n     * @dev     Swaps msg.value of strikeTokens (ethers) to underlyingTokens.\r\n     *          Uses the strike ratio as the exchange rate. Strike ratio = base / quote.\r\n     *          Msg.value (quote units) * base / quote = base units (underlyingTokens) to withdraw.\r\n     * @notice  This function is for options with WETH as the strike asset.\r\n     *          Burns option tokens, accepts ethers, and pushes out underlyingTokens.\r\n     * @param   optionToken The address of the option contract.\r\n     */\r\n    function safeExerciseWithETH(IOption optionToken)\r\n        public\r\n        payable\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(optionToken)\r\n        returns (uint256, uint256)\r\n    {c_0x27025830(0xfc5d51988735587be2a696be9889640929d10bd6d9bb1b9a315ff8f3017063ae); /* function */ \n\r\nc_0x27025830(0x7fa4ab3c7a2634adb951ae78d04bcc9b436c74ebe0299257741c5c54abd307ff); /* line */ \n        c_0x27025830(0x0a29df070fea9fd61595f70c924981cd1114923ddc7b55d3b62914854fc8b34f); /* requirePre */ \nc_0x27025830(0xf1c59908143a5c3c8862d925bf40f892eb67dce075c9f40af955ac2408f4d0e7); /* statement */ \nrequire(msg.value > 0, \"PrimitiveCore: ZERO\");c_0x27025830(0xa71b7b4c74bcf44ba5ab632e13cf9d886444c57534ca5caddb259ba8ae780639); /* requirePost */ \n\r\n\r\nc_0x27025830(0x85d97af30e271b7fcfbe57ef0a058b9402239753c8e4920165a29585eeb8eb13); /* line */ \n        c_0x27025830(0x41f50fde2efceb7f4c9f20c139c8da54656a77c88b0a3990a3f50551a0b7061e); /* statement */ \n_depositETH(); // Deposits `msg.value` to Weth contract.\r\n\r\nc_0x27025830(0x84805f642cfcc3c990ec1bdaf63b68442ecbff11d9992d7038f79396af11878e); /* line */ \n        c_0x27025830(0xe0488a56beba857e6c5ad5bb5e899708ad5eea5bcafdb9969cb70713dcb84f4e); /* statement */ \nuint256 long = CoreLib.getProportionalLongOptions(optionToken, msg.value);\r\nc_0x27025830(0xa09755235593e2cd7e552f9314ec8c3407da8ce09bb118530949b10ffc44715b); /* line */ \n        c_0x27025830(0x676e9d4683f1381a83e14305472b218a4b4a9de7587aa39dc2c4ae7bd347e180); /* statement */ \n_transferFromCaller(address(optionToken), long); // Pull option tokens.\r\n\r\n        // Pushes option tokens and weth (strike asset), receives underlying tokens.\r\nc_0x27025830(0x429d3ee034b33417a8459ae8983f447a31863e219a1d2ac550c4d9ed48a097c5); /* line */ \n        c_0x27025830(0x1bbab0a3a7bad3caab7e84e371d4c4827e27ce435d21ca58f348643e190b03f1); /* statement */ \nemit Exercised(getCaller(), address(optionToken), long);\r\nc_0x27025830(0x68de2d3bf1025e8c38bb1a97029029a32395582a723c5fad77959a1e42fbe825); /* line */ \n        c_0x27025830(0x033e366548049c3e244b0d654de2ee0ee04dfe5ed04958ddee569fedb51403ba); /* statement */ \nreturn _exerciseOptions(optionToken, long);\r\n    }\r\n\r\n    /**\r\n     * @dev     Swaps strikeTokens to underlyingTokens, WETH, which is converted to ethers before withdrawn.\r\n     *          Uses the strike ratio as the exchange rate. Strike ratio = base / quote.\r\n     * @notice  This function is for options with WETH as the underlying asset.\r\n     *          Burns option tokens, pulls strikeTokens, and pushes out ethers.\r\n     * @param   optionToken The address of the option contract.\r\n     * @param   exerciseQuantity Quantity of optionTokens to exercise.\r\n     */\r\n    function safeExerciseForETH(IOption optionToken, uint256 exerciseQuantity)\r\n        public\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(optionToken)\r\n        returns (uint256, uint256)\r\n    {c_0x27025830(0x01718b0d4478913db334c0cddd410cbc10bf3a7e92eae3941dd8fd6f0aaea93a); /* function */ \n\r\nc_0x27025830(0xef295bb707bec67c42b25b79b68146261f1e22c015eaaa96babb7242b398d6f0); /* line */ \n        c_0x27025830(0x395fa1959aa8d29d4dd37736185c310805b02044728556f6fb3233dfec7069ff); /* statement */ \naddress underlying = optionToken.getUnderlyingTokenAddress();\r\nc_0x27025830(0x0a702955445e08eaedb53f8f542c18fa33d331d5bdf890bb728d4aa77a4cd123); /* line */ \n        c_0x27025830(0x1f9aa0b4c191cd6759a6d9b5d72a42c86706f115e4e09c9277acc1ab86d5eb7d); /* statement */ \naddress strike = optionToken.getStrikeTokenAddress();\r\nc_0x27025830(0x8532902e782588802be01d6665222819f2b45c05820cdcf9d5084ed5c75d56ba); /* line */ \n        c_0x27025830(0x5c1ce416d11c9e275a6e1c4ddfedf26852937922832344d7348d035738f56ba3); /* statement */ \nuint256 strikeQuantity =\r\n            CoreLib.getProportionalShortOptions(optionToken, exerciseQuantity);\r\n        // Pull options and strike assets from `getCaller()` and send to option contract.\r\nc_0x27025830(0xfff088d2d8439e732bd8fb6c5c54893cd58aca6d450a05fe87c9ea039159a800); /* line */ \n        c_0x27025830(0x7a5e5c32f123a7c4c0b567b8300294c1ea38ea2214f0339cf0bb9122caa329c4); /* statement */ \n_transferFromCallerToReceiver(\r\n            address(optionToken),\r\n            exerciseQuantity,\r\n            address(optionToken)\r\n        );\r\nc_0x27025830(0x064e6c2ebde3fc99305b8ce34aa4c51311367d6c7aca57dd446e00b70b218303); /* line */ \n        c_0x27025830(0xdc50236ab7ec338fb38d7be7bced11e8950cd1945e62ab235340e3a0d4ecbd0e); /* statement */ \n_transferFromCallerToReceiver(strike, strikeQuantity, address(optionToken));\r\n\r\n        // Release underlying tokens by invoking `exerciseOptions()`\r\nc_0x27025830(0x476fa2c7d0a6c0d95d5bd2ee3b89242ce4f3f28a29e6aeb367e0b0855fcb78bd); /* line */ \n        c_0x27025830(0xf18ae9ec62ac1cc157d35611fc1b9b90bd19f037b7e39246262e8997487b53b9); /* statement */ \n(uint256 strikesPaid, uint256 options) =\r\n            optionToken.exerciseOptions(address(this), exerciseQuantity, new bytes(0));\r\nc_0x27025830(0x3b000cf826668fe0af6a5fb3eab4305622c8d19cab6163b51e730f5e6837c028); /* line */ \n        c_0x27025830(0x3f90903280eb173c3cefafdab1c99ec331a82d7b99503442140d910a6a7fa8d3); /* statement */ \n_withdrawETH(); // Unwraps this contract's balance of Weth and sends to `getCaller()`.\r\nc_0x27025830(0x48bfa3a1d9d70674a6d08e8db41c6db6eb06ae68c8d4e66d4178d65740d31be5); /* line */ \n        c_0x27025830(0x5faba8d3834d13db81f8b06104731a40f31b9bcb200aa9781dc0c800a0b4fed6); /* statement */ \nemit Exercised(getCaller(), address(optionToken), exerciseQuantity);\r\nc_0x27025830(0x1a7ef6a4577bfad60b1cba401907785e8e0c138d619ee42972f7f6e6ea9cbfdb); /* line */ \n        c_0x27025830(0x9be175699f4715a82421eeabea2cd3e74bbe18b6f475cb1668ab4f9dfe5e20a8); /* statement */ \nreturn (strikesPaid, options);\r\n    }\r\n\r\n    /**\r\n     * @dev     Burns redeem tokens to withdraw strike tokens (ethers) at a 1:1 ratio.\r\n     * @notice  This function is for options that have WETH as the strike asset.\r\n     *          Converts WETH to ethers, and withdraws ethers to the receiver address.\r\n     * @param   optionToken The address of the option contract.\r\n     * @param   redeemQuantity The quantity of redeemTokens to burn.\r\n     */\r\n    function safeRedeemForETH(IOption optionToken, uint256 redeemQuantity)\r\n        public\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(optionToken)\r\n        returns (uint256)\r\n    {c_0x27025830(0x26b484e1645bc10cc4ea40d7d6eef0061b27ab9c355e99824824228d52c4bed6); /* function */ \n\r\n        // Require the strike token to be Weth.\r\nc_0x27025830(0x3a4477a760644d350e5422da650eadf815a997418ede409a357155fc9f5e44c1); /* line */ \n        c_0x27025830(0xeb2fa4123c9290a63f708a8ef9e9733ae4e125a27196f872c74a90fab41b8f76); /* statement */ \naddress redeem = optionToken.redeemToken();\r\n        // Pull redeem tokens from `getCaller()` and send to option contract.\r\nc_0x27025830(0x45dbe687fa04eaddfa1f9f3a68a28026773776a51851c8ce8f32b0d8722a4043); /* line */ \n        c_0x27025830(0x3632969c1db18c52924e49c9e201df7f4a20de1a3ecef311ed80774efb921922); /* statement */ \n_transferFromCallerToReceiver(redeem, redeemQuantity, address(optionToken));\r\nc_0x27025830(0x5271ab1bce95c7949adbe4cc4aca2a1efb78b757041fd9e7cb7f98f29575f364); /* line */ \n        c_0x27025830(0x4192416a48aa800514b3bfa6fbe59b02845976cf72a2a227c4d4154b2a79a902); /* statement */ \nuint256 short = optionToken.redeemStrikeTokens(address(this));\r\nc_0x27025830(0x2c98780c539ab83f7027f15112fce2bc284389e260d20f58c64d760ce3a19264); /* line */ \n        c_0x27025830(0x3518fd3297b290b9c9faf282d0501800758f2f92239e40da0493cfb3750adcb7); /* statement */ \n_withdrawETH(); // Unwraps this contract's balance of Weth and sends to `getCaller()`.\r\nc_0x27025830(0xcaadd5397ca1ff3e56bc242c576c67c5e592a1fdc3786746521c4dbe9591a3c1); /* line */ \n        c_0x27025830(0xff7f669eb55cc1c4b0b6c3634a9131fd4b9f9232c513192c08703d3d2c29d623); /* statement */ \nemit Redeemed(getCaller(), address(optionToken), redeemQuantity);\r\nc_0x27025830(0x6a32b806b35f88743b8fd2014d9bc4470c3b6f9f191390fa66e25772edad4d99); /* line */ \n        c_0x27025830(0x77bc6ebc236af3c11944594aed624d9220d79d190b45690d54743c885de54b50); /* statement */ \nreturn short;\r\n    }\r\n\r\n    /**\r\n     * @dev Burn optionTokens and redeemTokens to withdraw underlyingTokens (ethers).\r\n     * @notice This function is for options with WETH as the underlying asset.\r\n     * WETH underlyingTokens are converted to ethers before being sent to receiver.\r\n     * The redeemTokens to burn is equal to the optionTokens * strike ratio.\r\n     * inputOptions = inputRedeems / strike ratio = outUnderlyings\r\n     * @param optionToken The address of the option contract.\r\n     * @param closeQuantity Quantity of optionTokens to burn and an input to calculate how many redeems to burn.\r\n     */\r\n    function safeCloseForETH(IOption optionToken, uint256 closeQuantity)\r\n        public\r\n        override\r\n        nonReentrant\r\n        onlyRegistered(optionToken)\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {c_0x27025830(0xe73fdd6bf16a63ba7b460613764082c3dd11da4e3abf2c88381b224dad57256b); /* function */ \n\r\nc_0x27025830(0x688d115dff67e762490479eefbccf830608ef9b1d93f89f3d99d57f254f63056); /* line */ \n        c_0x27025830(0x3fdb53e0332300b669cf339146b9dc0537de34cf89772a6321846924b2a71b00); /* statement */ \naddress redeem = optionToken.redeemToken();\r\nc_0x27025830(0xeca4cbe8442c1e0f40c84aa497ea3d732565cc8d0478af93bc9a7529095978c9); /* line */ \n        c_0x27025830(0x551d05d81e81b9b9139d46018d7c578a8e9b70055a7c3ed536ba3e35367d6ef8); /* statement */ \nuint256 short = CoreLib.getProportionalShortOptions(optionToken, closeQuantity);\r\n        // Pull redeem tokens from `getCaller()` and send to option contract.\r\nc_0x27025830(0x49a6eb7b868d1ed6ff6a0347ec8ff845916ed1e716dd2c563f8857704fb33fe2); /* line */ \n        c_0x27025830(0xc1607c8b7220306fec34ffb48e8a2e51bef319d71af0d9dc02dd651bed1d1437); /* statement */ \n_transferFromCallerToReceiver(redeem, short, address(optionToken));\r\n        // Pull options if not expired, and send to option contract.\r\nc_0x27025830(0x5ae73c1c9fc0fcbb93f7f470355310c6eea99437a326b857b54bb47cd2d59a3f); /* line */ \n        c_0x27025830(0xa17c761d9b15f19ad5a4cc2028b93b68d413807598b062673ce619acae9be2f5); /* statement */ \nif (optionToken.getExpiryTime() >= now) {c_0x27025830(0xb429c919696877c1ceb35aeee688261edad1b3748ecf4a12317a66234f9992f9); /* branch */ \n\r\nc_0x27025830(0xaa295c9ed1b5d71e7472767f3db5bfbcacefd5eb8742a70ddbb2975cc52bfa18); /* line */ \n            c_0x27025830(0xaf4f0af9a2bc67c7d15154068cd4f7e39dc6d76a15bd45f0d3a0bf831ef6cf75); /* statement */ \n_transferFromCallerToReceiver(\r\n                address(optionToken),\r\n                closeQuantity,\r\n                address(optionToken)\r\n            );\r\n        }else { c_0x27025830(0x3a1d41dc3fe805a835c88112316e145ca5f06da0ce18c21990caf74f9b2e5a19); /* branch */ \n}\r\n        // Release underlyingTokens by invoking `closeOptions()`\r\nc_0x27025830(0xf14738312d648a690af10c5a938046b08f2fd429d4467e7f73f46dbb2b34bd3f); /* line */ \n        c_0x27025830(0xe737ea5cd8e20b764d1a90ca927a9adf1409dfee99b24c0af24313f7a0e52276); /* statement */ \n(uint256 inputRedeems, uint256 inputOptions, uint256 outUnderlyings) =\r\n            optionToken.closeOptions(address(this));\r\n\r\nc_0x27025830(0x9a6ac2c344a6367eef0e5a6d5f7390c1919f6276bc955c0071821d805a9c5bb2); /* line */ \n        c_0x27025830(0x1f8afea2e68495349245f76c894e7213609849c9541b8e262d6043aff6ce1d1a); /* statement */ \n_withdrawETH(); // Unwraps this contract's balance of Weth and sends to `getCaller()`.\r\nc_0x27025830(0xa45f7838d50ed0ec1c6722f5fbd17c258c7e110ab01aa610acbdbaefefebdba5); /* line */ \n        c_0x27025830(0x959ff3eefb2ef87b1cedc45e5dde5eebdda2ddfca561e2da9221f7450aaa65fb); /* statement */ \nemit Closed(getCaller(), address(optionToken), closeQuantity);\r\nc_0x27025830(0x713b3a77036e10f159fa854d6420ffcaf62acdf9e7c5b212b53d59443a58510b); /* line */ \n        c_0x27025830(0x4d2d9fed0f6440980a502f11312742f0d86e9356d75da391504e279d1ee09410); /* statement */ \nreturn (inputRedeems, inputOptions, outUnderlyings);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": false
    }
  }
}